<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>大厂刷题 | 冯手力-java学习之路</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.49d708b7.css" as="style"><link rel="preload" href="/assets/js/app.830e2a66.js" as="script"><link rel="preload" href="/assets/js/2.fa03b954.js" as="script"><link rel="preload" href="/assets/js/1.f1cca222.js" as="script"><link rel="preload" href="/assets/js/24.300b4c09.js" as="script"><link rel="prefetch" href="/assets/js/10.32e354e9.js"><link rel="prefetch" href="/assets/js/100.df72f117.js"><link rel="prefetch" href="/assets/js/101.a7888046.js"><link rel="prefetch" href="/assets/js/102.1762a425.js"><link rel="prefetch" href="/assets/js/11.5539cea8.js"><link rel="prefetch" href="/assets/js/12.50e02eac.js"><link rel="prefetch" href="/assets/js/13.c78aae53.js"><link rel="prefetch" href="/assets/js/14.c5986c9c.js"><link rel="prefetch" href="/assets/js/15.c77a72c0.js"><link rel="prefetch" href="/assets/js/16.f39aca3f.js"><link rel="prefetch" href="/assets/js/17.8a271010.js"><link rel="prefetch" href="/assets/js/18.aa7ae899.js"><link rel="prefetch" href="/assets/js/19.8fd6b741.js"><link rel="prefetch" href="/assets/js/20.1dd4312c.js"><link rel="prefetch" href="/assets/js/21.99993c8a.js"><link rel="prefetch" href="/assets/js/22.9e7c61f5.js"><link rel="prefetch" href="/assets/js/23.244ff69e.js"><link rel="prefetch" href="/assets/js/25.9dbb24b0.js"><link rel="prefetch" href="/assets/js/26.f5b3acff.js"><link rel="prefetch" href="/assets/js/27.17a2c02d.js"><link rel="prefetch" href="/assets/js/28.8806ecf2.js"><link rel="prefetch" href="/assets/js/29.ab26f7f8.js"><link rel="prefetch" href="/assets/js/3.d7299546.js"><link rel="prefetch" href="/assets/js/30.5aecb640.js"><link rel="prefetch" href="/assets/js/31.0fb54f23.js"><link rel="prefetch" href="/assets/js/32.28bb7368.js"><link rel="prefetch" href="/assets/js/33.309a1357.js"><link rel="prefetch" href="/assets/js/34.32a3b981.js"><link rel="prefetch" href="/assets/js/35.6694ab2b.js"><link rel="prefetch" href="/assets/js/36.dbe2ea38.js"><link rel="prefetch" href="/assets/js/37.ce247cd3.js"><link rel="prefetch" href="/assets/js/38.a199607f.js"><link rel="prefetch" href="/assets/js/39.e5840ab8.js"><link rel="prefetch" href="/assets/js/4.1645b489.js"><link rel="prefetch" href="/assets/js/40.cfa08f31.js"><link rel="prefetch" href="/assets/js/41.dc041ba1.js"><link rel="prefetch" href="/assets/js/42.c63abf19.js"><link rel="prefetch" href="/assets/js/43.4a679a90.js"><link rel="prefetch" href="/assets/js/44.1441202c.js"><link rel="prefetch" href="/assets/js/45.5af96856.js"><link rel="prefetch" href="/assets/js/46.47c7a7f0.js"><link rel="prefetch" href="/assets/js/47.5ef911e5.js"><link rel="prefetch" href="/assets/js/48.fed1a229.js"><link rel="prefetch" href="/assets/js/49.2537e990.js"><link rel="prefetch" href="/assets/js/5.bcefa2d8.js"><link rel="prefetch" href="/assets/js/50.8f1a2b40.js"><link rel="prefetch" href="/assets/js/51.e4b7981a.js"><link rel="prefetch" href="/assets/js/52.549293e5.js"><link rel="prefetch" href="/assets/js/53.dd548c90.js"><link rel="prefetch" href="/assets/js/54.eff934fa.js"><link rel="prefetch" href="/assets/js/55.af614b80.js"><link rel="prefetch" href="/assets/js/56.c7771a0a.js"><link rel="prefetch" href="/assets/js/57.fff4bb3f.js"><link rel="prefetch" href="/assets/js/58.2c20774b.js"><link rel="prefetch" href="/assets/js/59.3f1e724f.js"><link rel="prefetch" href="/assets/js/6.5d056ffb.js"><link rel="prefetch" href="/assets/js/60.7c13eb79.js"><link rel="prefetch" href="/assets/js/61.9b5b8e34.js"><link rel="prefetch" href="/assets/js/62.e77e3444.js"><link rel="prefetch" href="/assets/js/63.6e685173.js"><link rel="prefetch" href="/assets/js/64.3218c058.js"><link rel="prefetch" href="/assets/js/65.ea7d1b9b.js"><link rel="prefetch" href="/assets/js/66.68b0658f.js"><link rel="prefetch" href="/assets/js/67.39051508.js"><link rel="prefetch" href="/assets/js/68.b82b8304.js"><link rel="prefetch" href="/assets/js/69.794f877f.js"><link rel="prefetch" href="/assets/js/7.682f29ed.js"><link rel="prefetch" href="/assets/js/70.c37e079e.js"><link rel="prefetch" href="/assets/js/71.af029f0f.js"><link rel="prefetch" href="/assets/js/72.379ac685.js"><link rel="prefetch" href="/assets/js/73.edf16484.js"><link rel="prefetch" href="/assets/js/74.1d3e5f77.js"><link rel="prefetch" href="/assets/js/75.49f5a107.js"><link rel="prefetch" href="/assets/js/76.bc1f6433.js"><link rel="prefetch" href="/assets/js/77.c84a57b8.js"><link rel="prefetch" href="/assets/js/78.915c7cbc.js"><link rel="prefetch" href="/assets/js/79.5d411a00.js"><link rel="prefetch" href="/assets/js/80.324dec28.js"><link rel="prefetch" href="/assets/js/81.6f80941a.js"><link rel="prefetch" href="/assets/js/82.f44052c2.js"><link rel="prefetch" href="/assets/js/83.8b5bd70a.js"><link rel="prefetch" href="/assets/js/84.4c629d81.js"><link rel="prefetch" href="/assets/js/85.d7acd0f3.js"><link rel="prefetch" href="/assets/js/86.3c4c4f31.js"><link rel="prefetch" href="/assets/js/87.c29b4416.js"><link rel="prefetch" href="/assets/js/88.4f03a6b5.js"><link rel="prefetch" href="/assets/js/89.015d7805.js"><link rel="prefetch" href="/assets/js/90.6d5cda23.js"><link rel="prefetch" href="/assets/js/91.309ce289.js"><link rel="prefetch" href="/assets/js/92.2fa10f1d.js"><link rel="prefetch" href="/assets/js/93.36515d6d.js"><link rel="prefetch" href="/assets/js/94.cafd24dc.js"><link rel="prefetch" href="/assets/js/95.7e550ccb.js"><link rel="prefetch" href="/assets/js/96.219aba1f.js"><link rel="prefetch" href="/assets/js/97.263eb873.js"><link rel="prefetch" href="/assets/js/98.d68c3308.js"><link rel="prefetch" href="/assets/js/99.1528fa2a.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.ee96d353.js">
    <link rel="stylesheet" href="/assets/css/0.styles.49d708b7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">冯手力-java学习之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/操作/" class="nav-link">
  操作
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="经验" class="dropdown-title"><span class="title">经验</span> <span class="arrow down"></span></button> <button type="button" aria-label="经验" class="mobile-dropdown-title"><span class="title">经验</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/工作经验/" class="nav-link">
  工作经验
</a></li><li class="dropdown-item"><!----> <a href="/项目经验/" class="nav-link">
  项目经验
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术相关" class="dropdown-title"><span class="title">技术相关</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术相关" class="mobile-dropdown-title"><span class="title">技术相关</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          java技术
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/java/" class="nav-link">
  java
</a></li><li class="dropdown-subitem"><a href="https://github.com/hehonghui/mockito-doc-zh#0" target="_blank" rel="noopener noreferrer" class="nav-link external">
  mockito
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://blog.csdn.net/xiao__jia__jia/article/details/115252780" target="_blank" rel="noopener noreferrer" class="nav-link external">
  mockito详解
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><!----> <a href="/数据库/" class="nav-link">
  数据库技术
</a></li></ul></div></div><div class="nav-item"><a href="/架构之路/" class="nav-link">
  架构之路
</a></div><div class="nav-item"><a href="/领域驱动设计/" class="nav-link">
  领域驱动设计
</a></div><div class="nav-item"><a href="/源码解析/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/程序员英语/" class="nav-link">
  程序员英语
</a></div><div class="nav-item"><a href="/算法体系/" class="nav-link">
  算法体系
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="下拉目录测试" class="dropdown-title"><span class="title">下拉目录测试</span> <span class="arrow down"></span></button> <button type="button" aria-label="下拉目录测试" class="mobile-dropdown-title"><span class="title">下拉目录测试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/guide/ts/" class="nav-link">
  具体.md文档
</a></li><li class="dropdown-item"><!----> <a href="/guide/vue/test03.html" class="nav-link">
  文件夹下Readme
</a></li><li class="dropdown-item"><!----> <a href="https://www.baidu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  其他连接测试-百度链接
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/用友/" class="nav-link">
  用友
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/操作/" class="nav-link">
  操作
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="经验" class="dropdown-title"><span class="title">经验</span> <span class="arrow down"></span></button> <button type="button" aria-label="经验" class="mobile-dropdown-title"><span class="title">经验</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/工作经验/" class="nav-link">
  工作经验
</a></li><li class="dropdown-item"><!----> <a href="/项目经验/" class="nav-link">
  项目经验
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术相关" class="dropdown-title"><span class="title">技术相关</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术相关" class="mobile-dropdown-title"><span class="title">技术相关</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          java技术
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/java/" class="nav-link">
  java
</a></li><li class="dropdown-subitem"><a href="https://github.com/hehonghui/mockito-doc-zh#0" target="_blank" rel="noopener noreferrer" class="nav-link external">
  mockito
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://blog.csdn.net/xiao__jia__jia/article/details/115252780" target="_blank" rel="noopener noreferrer" class="nav-link external">
  mockito详解
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><!----> <a href="/数据库/" class="nav-link">
  数据库技术
</a></li></ul></div></div><div class="nav-item"><a href="/架构之路/" class="nav-link">
  架构之路
</a></div><div class="nav-item"><a href="/领域驱动设计/" class="nav-link">
  领域驱动设计
</a></div><div class="nav-item"><a href="/源码解析/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/程序员英语/" class="nav-link">
  程序员英语
</a></div><div class="nav-item"><a href="/算法体系/" class="nav-link">
  算法体系
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="下拉目录测试" class="dropdown-title"><span class="title">下拉目录测试</span> <span class="arrow down"></span></button> <button type="button" aria-label="下拉目录测试" class="mobile-dropdown-title"><span class="title">下拉目录测试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/guide/ts/" class="nav-link">
  具体.md文档
</a></li><li class="dropdown-item"><!----> <a href="/guide/vue/test03.html" class="nav-link">
  文件夹下Readme
</a></li><li class="dropdown-item"><!----> <a href="https://www.baidu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  其他连接测试-百度链接
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/用友/" class="nav-link">
  用友
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/%E7%AE%97%E6%B3%95%E4%BD%93%E7%B3%BB/" aria-current="page" class="sidebar-link">算法体系学习</a></li><li><a href="/算法体系/算法基础.html" class="sidebar-link">算法基础学习</a></li><li><a href="/算法体系/算法新手班.html" class="sidebar-link">算法新手班</a></li><li><a href="/算法体系/大厂刷题.html" class="active sidebar-link">大厂刷题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#coding问题" class="sidebar-link">coding问题</a></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#二分答案法" class="sidebar-link">二分答案法</a></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#窗口问题" class="sidebar-link">窗口问题</a></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#堆问题" class="sidebar-link">堆问题</a></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#字符串问题" class="sidebar-link">字符串问题</a></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#位运算题" class="sidebar-link">位运算题</a></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#数组问题-预处理数组" class="sidebar-link">数组问题(预处理数组)</a></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#由小构建大的问题-分治" class="sidebar-link">由小构建大的问题,分治</a></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#动态规划问题" class="sidebar-link">动态规划问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#暴力递归" class="sidebar-link">暴力递归</a></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#动态规划-从左往右模型" class="sidebar-link">动态规划-&gt;从左往右模型</a></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#动态规划-样本对应模型" class="sidebar-link">动态规划-&gt;样本对应模型</a></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#动态规划-范围尝试模型" class="sidebar-link">动态规划-&gt;范围尝试模型</a></li></ul></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#树-二叉树" class="sidebar-link">树-二叉树</a></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#前缀树" class="sidebar-link">前缀树</a></li><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#并查集" class="sidebar-link">并查集</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/算法体系/大厂刷题.html#贪心问题" class="sidebar-link">贪心问题</a></li></ul></li></ul></li><li><a href="/算法体系/7-堆-被火车撞了都不能忘记的结构.html" class="sidebar-link">堆-被火车撞了都不能忘记的结构</a></li><li><a href="/算法体系/11-二叉树.html" class="sidebar-link">二叉树</a></li><li><a href="/算法体系/15-并查集-查连通区域神器.html" class="sidebar-link">并查集-查连通区域神器</a></li><li><a href="/算法体系/17-图.html" class="sidebar-link">图</a></li><li><a href="/算法体系/18-暴力递归到动态规划.html" class="sidebar-link">暴力递归到动态规划</a></li><li><a href="/算法体系/25-滑动窗口内最大值或最小值问题.html" class="sidebar-link">滑动窗口内最大值或最小值问题</a></li><li><a href="/算法体系/26-单调栈.html" class="sidebar-link">单调栈</a></li><li><a href="/算法体系/28-KMP算法.html" class="sidebar-link">KMP算法</a></li><li><a href="/算法体系/29-Manacher算法.html" class="sidebar-link">Manacher算法</a></li><li><a href="/算法体系/30-蓄水池算法.html" class="sidebar-link">蓄水池算法</a></li><li><a href="/算法体系/30-bfprt算法-topk.html" class="sidebar-link">bfprt算法</a></li><li><a href="/算法体系/31-Morris遍历.html" class="sidebar-link">Morris遍历</a></li><li><a href="/算法体系/32-线段树.html" class="sidebar-link">线段树</a></li><li><a href="/算法体系/34-与哈希函数有关的数据结构.html" class="sidebar-link">与哈希函数有关的数据结构</a></li><li><a href="/算法体系/35-资源限制类题目解题思路.html" class="sidebar-link">资源限制类题目解题思路</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="大厂刷题"><a href="#大厂刷题" class="header-anchor">#</a> 大厂刷题</h1> <h2 id="coding问题"><a href="#coding问题" class="header-anchor">#</a> coding问题</h2> <h4 id="心得"><a href="#心得" class="header-anchor">#</a> 心得:</h4> <ol><li>如果求任意某个数超过一半,那么就每次消灭2个不同的,最后剩下来的,&quot;有可能&quot;是.</li> <li>如果求一堆中答案中的最小值,那么注意,初始值应该为最大值,然后被答案覆盖.</li> <li>带括号的字符串解析套路:全部可以这样解:我的方法只处理最简单的,然后遇到左括号就开启子递归,遇到右括号或结束就返回2个值,一个是结果,一个是处理到的位置.</li></ol> <h4 id="超级水王问题"><a href="#超级水王问题" class="header-anchor">#</a> 超级水王问题</h4> <p>https://www.bilibili.com/video/BV16o4y1c77G?p=182&amp;vd_source=aa2ca96f997833d2dcbb3cf9f4cd33ac</p> <blockquote><p>在一个数组中,如果有一个数超过一半,那他就是超级水王,返回超级水王,如果不存在,返回null.额外空间O(1),时间复杂度O(N)</p></blockquote> <p>我们把超级水王比喻为子弹,把其他的数字比喻为靶子,如果水王超过一半,那么每颗子弹消耗一个靶子后,那么他一定还有剩余,例如,<code>[1,2,1,3,1]</code>这个数组,否则一定不存在,但是注意,如果有剩余,也不一定存在超级水王,需要再过一遍数组,例如<code>[1,2,3,4,5]</code></p> <h4 id="完美走位问题"><a href="#完美走位问题" class="header-anchor">#</a> 完美走位问题.</h4> <p>https://leetcode.cn/problems/replace-the-substring-for-balanced-string/description/</p> <blockquote><p>原题描述:</p> <p>程序接收一个表示走位的字符串，通过统计A、S、D、W四个键的出现次数，然后使用滑动窗口和双指针技术寻找并返回能将走位变为完美走位的最小子串替换长度。如果原始走位已经是完美走位，则返回0。</p> <p>翻译版本:</p> <p>有一个只含有 <code>'Q', 'W', 'E', 'R'</code> 四种字符，且长度为 <code>n</code> 的字符串。</p> <p>假如在该字符串中，这四个字符都恰好出现 <code>n/4</code> 次，那么它就是一个「平衡字符串」。</p> <p>给你一个这样的字符串 <code>s</code>，请通过「替换一个子串」的方式，使原字符串 <code>s</code> 变成一个「平衡字符串」。</p> <p>你可以用和「待替换子串」长度相同的 <strong>任何</strong> 其他字符串来完成替换。</p> <p>请返回待替换子串的最小可能长度。</p> <p>如果原字符串自身就是一个平衡字符串，则返回 <code>0</code>。</p></blockquote> <p>思路:</p> <p>这个一个窗口题,中等偏难的难度.假如我有一个方法,我给他一个LR范围,看看这一段,随意变化,是否能让整体符合条件,</p> <p>从0开始,如果0-0不行,那我试试0-1,0-2试试,如果0-3可以了,则我得到了一个答案,以0开头,最小的一个答案,</p> <p>然后,我让L右扩,1-3能不能行,如果可以,那最小答案就是1-3,范围更小了</p> <p>假设1-3不行,那1-4呢,1-5呢,如果1-5可以,又得到一个答案,那我试试2-5,</p> <p>直到,我得到min(所有答案的长度).</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">balancedString</span><span class="token punctuation">(</span><span class="token string">&quot;QQRR&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">balancedString</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//转换qwer为0123值</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//qwer对应0123,统计一个词频统计</span>
    <span class="token comment">//cnt 窗口外面的词频统计,一开始所有字符都在窗口外面,所以这里直接初始化</span>
    <span class="token keyword">int</span> cnt<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">char</span> aChar <span class="token operator">=</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>aChar<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token char">'Q'</span><span class="token operator">:</span>
                temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token char">'W'</span><span class="token operator">:</span>
                temp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token char">'E'</span><span class="token operator">:</span>
                temp <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token char">'R'</span><span class="token operator">:</span>
                temp <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//转换完成</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token comment">//词频统计完成</span>
        cnt<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//长度一定是4的倍数,那么所有的字符全部调整一遍,也就是调整n个字符,一定可以做到.所以初始答案是n不是0.!!</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//这个lr范围,我怎么变都搞不定 并且 我都扩到头了都搞不定</span>
        <span class="token comment">//如果不能做到,右扩窗口,如果扩到头了,也退出.还是搞不定</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ok</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> l<span class="token punctuation">,</span>r<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//这个什么意思??一开始,LR都是0,cnt包括所有的词频统计,r右扩后,区分里外,范围外,词频统计减去窗口内的值.</span>
            <span class="token comment">//窗口扩大,外面的词频统计减少</span>
            cnt<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>r<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>

        <span class="token comment">//上面跳出的2种情况</span>
        <span class="token comment">//1,能做到了,那么我要L右扩了,</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ok</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//我收集一个答案,并且取最小的.</span>
            result <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">//2.做不到,真的做不到,扩到头了都做不到,没得算了.</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//l右扩,窗口减少,左侧的出窗口,进入到窗口外词频统计</span>
        cnt<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 拉齐窗口外面的短的到一样长,然后里面的剩余的字符,能均分,就说明ok,否则搞不定
 * @param cnt 窗口外面的词频统计
 * @param l
 * @param r
 * @return
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cnt<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//哪个字母个数最多</span>
    <span class="token keyword">int</span> maxCount <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>cnt<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cnt<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>cnt<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cnt<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//凑4个字母的n份,就是maxCount * 4,减去窗口外面的,就是窗口内部的需要变多少个.</span>
    <span class="token keyword">int</span> needChanged <span class="token operator">=</span> maxCount <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">-</span> cnt<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> cnt<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span> cnt<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-</span> cnt<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">//区间内,除去需要补齐4份的,剩下的正好能变 4个字母 * n份,代表能搞定.</span>
    <span class="token keyword">int</span> rest <span class="token operator">=</span> r<span class="token operator">-</span>l<span class="token operator">-</span>needChanged<span class="token punctuation">;</span>
    <span class="token comment">//剩下的正好整除4</span>
    <span class="token keyword">return</span> rest <span class="token operator">&gt;=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> rest <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="双人乘船过河问题"><a href="#双人乘船过河问题" class="header-anchor">#</a> 双人乘船过河问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34953&amp;courseVersionId=1348</p> <blockquote><p>给定一个正数数组arr，代表若干人的体重</p> <p>再给定一个正数limit，表示所有船共同拥有的载重量</p> <p>每艘船最多坐两人，且不能超过载重</p> <p>想让所有的人同时过河，并且用最好的分配方法,让船尽量少,返回最少的船数</p></blockquote> <p>思路:</p> <p>我先给整个人的体重排序,然后,找到一个limit/2位置的值,在这个地方,左右,设置LR指针,</p> <p>然后,此时L左移,不能配对就打叉,直到遇到第一个能配对的,不急着分配,R右移,直到遇到第一个不能配对的位置.R移动了几个位置,就拿L左侧的多少个值来配对,这样是最划算的,直接来给这R右移的所有的消化掉.搞定完了后,L从消耗完了的位置,继续重复上述步骤....R右移,消耗左侧右移位数个,</p> <p>这样下来,总有一侧先耗尽的时候.</p> <p>1.左侧先耗尽,</p> <p>左侧的,滑过的,打叉的,直接除2一船,2人肯定能坐下,如果左侧最小的+右侧最大的超过limit,那么,肯定左侧先耗尽,左侧全部打叉.</p> <p>那结果就是,✅/2 + 打叉的/2+右侧剩余的 = 所有需要的船</p> <p>2.右侧先耗尽.</p> <p>左侧没消耗的,剩下的全部打叉,✅/2+画叉子的/2 就是需要的船</p> <h4 id="奇偶层树节点分配后差值-1问题"><a href="#奇偶层树节点分配后差值-1问题" class="header-anchor">#</a> 奇偶层树节点分配后差值&lt;=1问题</h4> <p>https://www.bilibili.com/video/BV16o4y1c77G?p=5&amp;vd_source=aa2ca96f997833d2dcbb3cf9f4cd33ac</p> <blockquote><p>来自腾讯音乐
给定一棵树，一共有n个点,每个点上没有值，</p> <p>请把1~n这些数字，不重复的分配到二叉树上</p> <p>做到 :奇数层节点的值总和 与 偶数层节点的值总和 相差不超过1</p> <p>返回奇数层节点分配值的一个方案</p> <p>2 &lt;=n&lt;= 10^5</p> <p>假设5个节点,就是给1~5这个数字,分配到树上,然后,奇偶层查值&lt;=1</p></blockquote> <p>首先,这个题,上来提到一棵树,但是他实际上是蛊惑你的,这个和树的关系不是非常的大,他求得是奇偶层的总和的比较.也就是,大约一半的节点数,,凑到所有数字累加和的一半,怎么凑.</p> <p>这个题,数据量,10的5次方,如果做动态规划,这个表就爆了,所以这不是个动态规划题.</p> <p>我们这样想,首先,得到一半的大小,然后确实是尽量去凑这个数,但是怎么凑,是重点.</p> <p>我们先让k个数,分别取前k个,重点来了,我们看看边界,假如,我前面k个数,都比这个sum/2值(基数可能差1偶数必须相等)大,或者最后k个数,都没有sum/2值小,那么一定没结果,否则一定有值.我们只需要求一个.</p> <p>假设,100个节点, 我们需要知道,奇数偶数层各多少节点,</p> <p>例如1,49,51个,那么我们总数sum/2是5050,假设我们求凑x=50,或者x&gt;100000,那么我们知道肯定没有答案,如果假设凑500,那么我们知道肯定有答案.那么就是说,k=49个数,我们要凑5050,或者前面的凑不出,51个数,我们要凑5050,首先我们算一个前49个数的小和,(1+49)*49/2=sumMinK,然后,我们看看单个数字能提升多少,就是让第49位的数,移动到100,单个数可以提升range=51,那么我们让(5050-sumMinK)/range = 需要移动多少个数字,我们让这些数字一次挪到后面,然后,5050-sumMinK)%range ,就是一个数,不需要完整的移动一个range,这些移动的数字和前面的每移动过的,全部加载一起,即是答案.</p> <h4 id="大楼轮廓线问题"><a href="#大楼轮廓线问题" class="header-anchor">#</a> 大楼轮廓线问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34961&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/the-skyline-problem/</p> <p>思路:我们把输入值,按照起点排序,他升高到了某个点什么时候结束,不知道,要么,被其他升高的打断了,升的更高了,要么,自己到头了.掉下来了.</p> <p>我们可以拆分这个输入值,组成2个对象,{起点,升高,升高值},{终点,降落,降落值},按照起点,,排序</p> <p>我们要求的是每一个变化点或者每一个大楼高度有变化的点的轮廓,我们就记录下来每个点的数据,将上面的对象,2*N个输入值,因为一升一降,放到有序表里,怎么放,如果是true,按照升高值作为k,然后val+1,如果是false,按照下降至val-1,如果val = 0了,整条记录删除掉.</p> <p>准备两个有序表,一个记录,最大高度为k,v为次数,另一个,记录,每个x位置,就是起点位置终点位置的最大高度是多少.我希望有序,所以用有序表.用linkedHashMap也行,因为我依次记录的.</p> <p>为什么0次了,整条记录要干掉,不留着0,因为我要,求最大的k,他会干扰我.</p> <p>用第一个有序表得到第二个有序表,即x位置最大高度,</p> <p>然后根据x位置最大高度,得到轮廓线答案.</p> <h4 id="字符串公式解析问题"><a href="#字符串公式解析问题" class="header-anchor">#</a> 字符串公式解析问题.</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=52248&amp;courseVersionId=1348</p> <blockquote><p>给定一个字符串str，str表示一个公式</p> <p>公式里可能有整数,加减乘除符号和左右括号</p> <p>返回工时的计算结果,难点在于括号可能嵌套很多层</p> <p><code>str=&quot;48*((70-65)-43)+8*1&quot;</code>，返回-1816。</p> <p><code>str=&quot;3+1*4&quot;</code>返回7。</p> <p><code>str=&quot;3+(1*4)&quot;</code></p> <p>【说明】</p> <ol><li>可以认为给定的字符串一定是正确的公式,不需要检查有效性</li> <li>如果是负数 就需要用括号括起来，比如<code>4*(-3)</code>,但是如果他作为开头或括号部分的开头,咋可以没有括号,例如<code>-3*4和(-3)*4</code>都是合法的.</li> <li>不用考虑计算过程中会发生溢出的情况。</li></ol></blockquote> <p>思路:</p> <p>这个题,我们用递归做,我每个方法中,只做最简单的加减乘除计算,记作int[] ans = f(arr,i)方法</p> <p>其中,f方法,定义为:只计算简单的公式,如果遇到左括号,则开启新的子方法,等待返回值,返回值包括两个值,1.当前方法的计算结果,2.计算到str的位置.什么时候返回,当结束了,或者,遇到了右括号的时候.</p> <p>简单计算方法,做一个栈,设置一个cur=0,遇到数字就cur*10然后加当前值,如果遇到符号,数字,符号依次放到栈中,当一个数加入到栈中时候,如果是乘除符号,直接拿出来,做一个计算,计算完了后,再整个将结果放进去.每个方法遇到左括号就开启新方法,这样每个方法都是最简单的计算.</p> <p>-3这种负数怎么办.没关系.cur是0,0*10先进栈,负号进栈,3进栈,就是0-3嘛.答案就是-3,完全兼容了!!!</p> <p>用这个套路,都可以解决,什么压缩后是abc3{aabbcc} 的,问原先字符什么样的,一样的解析.</p> <h4 id="_14-1-88-返回左右括号组成的字符串-最长的有效子串长度"><a href="#_14-1-88-返回左右括号组成的字符串-最长的有效子串长度" class="header-anchor">#</a> 14-1-88 返回左右括号组成的字符串,最长的有效子串长度</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35017&amp;courseVersionId=1348</p> <blockquote><p>给定一个只由左括号和右括号的字符串
返回最长的有效括号子串的长度</p></blockquote> <p>看到子串了吧,那就是遍历展开,然后以i位置结尾,最长,往前推多远.</p> <p>basecase :</p> <ul><li>i==0时,一定不可能,就一个怎么凑对呢.</li> <li>i==1是,得是右括号,并且0位置的得是左括号,那他才是2,否则,0.</li></ul> <p>普遍位置:</p> <p>i位置时,看下他前面一个,如果他前面一个,一点都推不动,是0,那看看他俩能不能凑对,凑上了就是2,凑不上就是0,如果他前面凑上了,例如8,那他就要和i-8-1位置去凑对,凑上了,就是8+2,别急,还没完,i-8-1位置的前一个,还得看看,如果不是0,那还得加上,一路走来,不是0就记录一个最大值,遍历完了后,返回最大值.</p> <h4 id="如果排序后-相邻两数最大差值问题"><a href="#如果排序后-相邻两数最大差值问题" class="header-anchor">#</a> 如果排序后,相邻两数最大差值问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=52880&amp;courseVersionId=1348</p> <blockquote><p>给定一个数组arr，返回如果排序之后，相邻两数的最大差值
要求:时间复杂度O(N)</p></blockquote> <p>假设答案法!!</p> <p>注意,是如果排序,不是真的排序,排序就已经O(N*logN)了</p> <p>这个题非常难,难住很多国手,因为一般N*logN ,logN不会很大,一般当做较大的常数项了.而本题要求了,O(N)</p> <p>这个题,不需要扩散性思维,出现这种题,就是非常难,记住这个一个题就行了,足够了.</p> <p>这个题,利用了个桶排序的思想,桶排序,可以做到O(N)</p> <p>假设答案是什么意思,我就假设:9个数,最小值0,最大数99,那我分10个桶,一定有一个会是空桶,如果是13个数呢,那就14个桶,分数一样的算,我取10个桶只是为了示例.</p> <p>好,意义是什么,我9个数分10个桶,必有一个空桶,那么就是说,单个桶内,必不可能出现答案,也不一定是在空桶两侧,不一定的啊,例如1-19,差值18,19-31,差值才12,所以这个只是为了排除答案不可能出现在单个桶内.每个桶,只需要保留2个信息,最大值多少,最小值多少.</p> <p>然后全过一遍后,每个桶的最大最小减一下,答案就知道了.</p> <h4 id="_9-1-58-线型点灯和环形点灯问题"><a href="#_9-1-58-线型点灯和环形点灯问题" class="header-anchor">#</a> 9-1-58.线型点灯和环形点灯问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=57229&amp;courseVersionId=1348</p> <blockquote><p>给定一个数组arr，长度为N，a中的值不是0就是1。arr[i]表示第i栈灯的状态，0代表灭灯，1代表亮灯</p> <p>每一栈灯都有开关，但是按下i号灯的开关，会同时改变i-1、i、i+1栈灯的状态</p> <p>问题一:如果N栈灯排成一条直线,请问最少按下多少次开关灯全亮?</p> <p>i为中间位置时，i号灯的开关能影响i-1、i和i+1</p> <p>0号灯的开关只能影响0和1位置的灯</p> <p>N-1号灯的开关只能影响N-2和N-1位置的灯</p> <p>问题二:如果N栈灯排成一个圈,请问最少按下多少次开关,能让灯都亮起来</p> <p>i为中间位置时，i号灯的开关能影响i-1、i和i+1</p> <p>0号灯的开关能影响N-1、0和1位置的灯</p> <p>N-1号灯的开关能影响N-2、N-1和0位置的灯</p></blockquote> <p>这个是以前字节的一个题,考的是第二个问题.这个题非常的难.</p> <p>其解题思路用到了体系学习班最后的那个,结合外部信息猜解法的思想.</p> <p>思路:</p> <p>这个题,我们最麻烦的是,当前位置会改变已经做过决策位置的值,所以,我们要做出一个改变,我们当前位置的值,不由我改变,由我后面的改变.</p> <p>所以我定义的方法为,f(arr,nextIndex,preStatus,curStatus),参数含义为</p> <p>nextIndex:当前在i位置上,传i+1, nextIndex -1 = cur,当前,</p> <p>cur-1 为preStatus,</p> <p>cur 为 curStatus,</p> <p>隐含的含义就是,我以前的我都搞定了,都亮起来,我由nextIndex的决定来帮我亮起来,如果我是灭的,那么下个开关必须按,同时传下去f(arr,nextIndex+1,cur=cur^1 这个就是我取反,因为开关必须按,arr(nextIndex)^1 按了以后,下一个状态也取反),如果我是亮的,那么下一个一定不能按,那就直接当前变pre,next变当前,直接传下去.f(arr.nextIndex+1,curStatus,arr(nextIndex)).</p> <p>一直到最后,如果,最后一个开关,他俩都是亮的,那么不用按,如果都是灭的,开关按次数+1,否则状态不一致,怎么都搞不定.</p> <p>第二问:</p> <p>第二问是环形了,跟上面的区别是,按0号灯会影响最后一个,最后一个会影响第一个,</p> <p>根据第一个启发,我们依然是保持上面的思路,区别是,我们加2个参数,记住第一个和最后一个的状态,然后,我们从第2个开始,注意,不从第一个开始了,因为从2开始,有普遍性,第一个比较特殊,然后,我们0,1,这两个位置的,我们穷举,0不按,1按,00,01,10,11,四种穷举,挨个调用,返回最小值.这样,就得到了答案.</p> <h4 id="_9-2-59-无效括号串变有效的所有可能结果"><a href="#_9-2-59-无效括号串变有效的所有可能结果" class="header-anchor">#</a> 9-2-59,无效括号串变有效的所有可能结果.</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=57230&amp;courseVersionId=1348</p> <p>首先,我们得知道,什么样的括号串,是错误的,那就是右括号比左括号多的时候,没有对应了.</p> <p>设置一个count,当遇到左括号时候,count++,遇到右扩号的时候,count--,当count位负数的时候,那就是出现错误的时候.</p> <p>那么,怎么修复这个错误的括号串,</p> <p>那就是,从第一个右括号开始,可以开始删除,当后面接着的都是右括号,那都是一样的结果,跳过,当再遇到左括号的时候,可以继续删除右括号.</p> <p>我定义的方法,传入的参数,剩余字符串,一个是我检查到哪里了,一个是我删除到哪里了,答案集合,再加一个当前传的字符(左括号还是右括号.),含义是,只要违规了,就给前缀调整对,任何一次调整完,我都return,</p> <p>当我正着调整完了,我确定,右扩号一定不必左括号多,那么好了,我左括号有可能比右括号多,我给字符串反转,然后最后一个参数,改为&quot;)&quot;,左右互换,这样再走完一遍,我这个字符串,绝对正确.</p> <p>这样走完了一遍了,我就收集到了一个答案.</p> <h4 id="_10-2-64-跳跃游戏"><a href="#_10-2-64-跳跃游戏" class="header-anchor">#</a> 10-2-64 跳跃游戏</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34993&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/jump-game-ii/</p> <blockquote><p>一个数组,每个值代表你从这里最远能跳多少步下去,返回跳到终点,最少需要多少步.</p></blockquote> <p>这个题,我们准备三个变量,</p> <p>step:当前用了多少步了,当我遍历到终点时候,这个值,就是答案.</p> <p>cur:当step增加的时候,我把next的值拷贝过来,next= null,如果i&gt;cur,那就是我需要增加步数了,增加步数时候,next拷贝过来,next=null</p> <p>next:提前准备好的,代表如果我多跳一步,我最远能到哪里,当数轴上面的值+下标大于我的时候,我就更新.</p> <h4 id="_13-3-86-超级洗衣机问题"><a href="#_13-3-86-超级洗衣机问题" class="header-anchor">#</a> 13-3-86 超级洗衣机问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35015&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/super-washing-machines/</p> <blockquote><p>就是说有N个洗衣机,每个洗衣机上面对着有衣服数量,每个洗衣机可以往左或往右扔一件衣服,一个回合内,所有的洗衣机都可以扔一次,问最少需要扔多少次.能让每个洗衣机上面的衣服一样多.</p></blockquote> <p>这个是一个求单个位置最大瓶颈问题,当一个瓶颈解决了的时候,全部就都解决了</p> <p>首先,我们要得到,每个洗衣机上,应该有多少衣服,然后,来一个衣服小和的前缀数组,每个位置i看下,我左边,右边,各欠多少或者赋予多少件衣服.几个情况:</p> <ol><li>如果一侧欠衣服,一侧富裕衣服,那就是取这两个值的max,就是i位置机器调整完的次数,</li> <li>如果两侧都欠,那也是取max,欠的多的调整完了,欠的少的肯定早调整完了,所以其实1,2是同样的处理方式</li> <li>如果两侧都富裕,也就是i位置欠的最多,那就是取左右的相加值,因为左右都给我,一次只能给1个,</li></ol> <h4 id="_16-2-98-arr子集不能累加出的最小正数问题"><a href="#_16-2-98-arr子集不能累加出的最小正数问题" class="header-anchor">#</a> 16-2-98-arr子集不能累加出的最小正数问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35027&amp;courseVersionId=1348</p> <blockquote><p>给定一个正数数组arr，
返回arr的子集不能累加出的最小正数
1）正常怎么做？
2）如果arr中肯定有1这个值，怎么做？</p></blockquote> <p>第一问:</p> <p>首先,又是子集,那肯定又是从左往右了,要或者不要,</p> <p>有点像16-1-97那个题,从左往右尝试,0~N,能不能搞定,能不能搞定2,能不能搞定3......搞不定,返回.</p> <p>第二问:</p> <p>我们先给数组排个序,</p> <p>我们不从0开始,假设从1开始,如果肯定有1,那么1~1范围上,能搞定1,如果2位置是1,或者2,那肯定能搞定1~3,我们引入一个变量,叫range,此时,1~2范围上,可以搞定range1~3,如果2位置不是1或2,而是3呢,那我们发现,2,怎么都搞定不了,返回2,这个条件是什么呢,i位置&gt;range+1,返回range+1,否则,range变成range+当前位置的值</p> <p>如果题目要求是0开始的,那我们最终结果页减一.</p> <p>如果不含1,那么最小的正整数就是1.</p> <h4 id="_16-3-99-patching-array问题"><a href="#_16-3-99-patching-array问题" class="header-anchor">#</a> 16-3-99-patching-array问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35026&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/patching-array/</p> <blockquote><p>给定一个数组nums,再给定一个整数n,</p> <p>nums随便选择子数组,问问补充几个数,能搞定1~N所有的组合.</p> <p>例如数组[1,5],n=10,问补充几个数,1~10全部能搞定.</p></blockquote> <p>还是上面的那个那个做法,我们要先搞定1~1,然后1~3,然后,,,其实就是让range再一个范围内,全部都能搞定,直到range超过n的时候,补充的数,就是我需要的数.</p> <p>首先是在使用给定数组之前的,例如[4,5,17,39],凑83,我想用4,那不行啊,我得现有range1,那我得补充个1,我让range涨到3,我得补充个2,然后我可以用4了,!!!range涨到7,我想用5,需要满足range4,已经满足了,所以,range涨到12,想用17不行,需要range16,我再来个13,range涨到了25,使用17,我的range涨到42,可以无缝衔接39,涨到81,好的,没数了,孤独的往上涨吧,来个82,range超过了83了,得到了答案</p> <h4 id="_16-4-100-求长度为2的power次方的数组中逆序对的问题"><a href="#_16-4-100-求长度为2的power次方的数组中逆序对的问题" class="header-anchor">#</a> 16-4-100-求长度为2的power次方的数组中逆序对的问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35029&amp;courseVersionId=1348</p> <blockquote><p>给定整数power，给定一个数组arr，给定一个数组reverse，
含义如下：
arr的长度一定是2的power次方
reverse中的每个值一定都在0~power范围。
例如power = 2, arr = {3, 1, 4, 2}，reverse = {0, 1, 0, 2}</p> <p>任何一个在前的数字可以和任何一个在后的数组，构成一对数
可能是升序关系、相等关系或者降序关系
比如arr开始时有如下的降序对：(3,1)、(3,2)、(4,2)，一共3个
接下来根据reverse对arr进行调整：
reverse[0] = 0, 表示在arr中，划分每1(2的0次方)个数一组然后每个小组内部逆序，那么arr变成[3,1,4,2]，此时有3个逆序对</p> <p>reverse[1] = 1, 表示在arr中，划分每2(2的1次方)个数一组，然后每个小组内部逆序，那么arr变成[1,3,2,4]，此时有1个逆序对</p> <p>reverse[2] = 0, 表示在arr中，划分每1(2的0次方)个数一组，然后每个小组内部逆序，那么arr变成[1,3,2,4]，此时有1个逆序对</p> <p>reverse[3] = 2, 表示在arr中，划分每4(2的2次方)个数一组，然后每个小组内部逆序，那么arr变成[4,2,3,1]，此时有4个逆序对</p> <p>所以返回[3,1,1,4]，表示每次调整之后的逆序对数量</p> <p>输入数据状况：
power的范围[0,20]
arr长度范围[1,10的7次方]
reverse长度范围[1,10的6次方]</p></blockquote> <p>这个题,暴力解,我每次调整完了后,算出逆序对,然后收集答案,可是你看看数据量,绝对不可能过的了.</p> <p>这个数据范围,最多,一个O(N*logN)</p> <p>这个题用到了一个归并排序的merge思想.我们求这个降序对,N^2遍历一遍,能得到,我们也可以像归并那种,先求两个一组,多少降序对,再求2^2,也就是4个一组,多少降序对,注意不算刚刚的2个一组的,再求2^3,也就是8个一组,多少降序对,注意不算刚刚4个一组的,然后2^4,......直到2^20次方,我们要的是,每个次方的降序对合,当这些全部加在一起的时候,就是整个的答案.</p> <p>上面说到的内容,我们用2个辅助数组,一个降序对,一个升序对.升序对,我们将整个源数组逆序,求降序对,就是升序对,一套方法搞定.</p> <p>重点来了,干嘛用.</p> <p>假如,我们2^3的数组,8个长度,2^1,2^2,2^3,三个逆序的范围的可能,例如现在来了个2次方的,实际就是4个逆序,左右逆序,但是左右,大的相对位置不变,例如[4,8,3,1,1,3,7,4],我们2^3时候,8个数一组,4个数来自左边,4个来自右边,如果现在2^2逆序了,影响2^3的吗?不影响,因为2^2逆序了,结果是[3,1,8,4,7,4,1,3],对于2^3来说,还是左边取4个配右边取4个,相对的位置不变.只有2^2,2^1变了,升序对变逆序对.</p> <p>所以,当我们得到了2个辅助数组后,每次直到哪个逆序了,直接从他往下的,升序逆序互换,数值全部相加,就是答案.!非常快.</p> <h4 id="_17-1-103-返回数组中有没有num的数"><a href="#_17-1-103-返回数组中有没有num的数" class="header-anchor">#</a> 17-1-103-返回数组中有没有num的数</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35032&amp;courseVersionId=1348</p> <blockquote><p>给定一个每一行有序、每一列也有序，整体可能无序的二维数组
再给定一个数num，
返回二维数组中有没有num这个数</p></blockquote> <p>这个题比较水,</p> <p>从左往右,从上往下,都有序,</p> <p>我从右上角开始,比num大吗?大就往左走,小就往下走,因为单边有序嘛.,一个m+n的复杂度,搞定</p> <p>或者从左下角开始,也是一样的,比num大就往上走,因为上面的小,比num小就往右走,一样的复杂度,但是左上,右下不行,没有单调性.</p> <h4 id="_16-6-102-约瑟夫环问题"><a href="#_16-6-102-约瑟夫环问题" class="header-anchor">#</a> 16-6-102-约瑟夫环问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35031&amp;courseVersionId=1348</p> <p>https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</p> <blockquote><p>约瑟夫环问题
给定一个链表头节点head，和一个正数m
从头开始，每次数到m就杀死当前节点
然后被杀节点的下一个节点从1开始重新数，
周而复始直到只剩一个节点，返回最后的节点</p></blockquote> <p>剃刀函数,这样的都从基础通项公式入手:y=x%i</p> <p>左加右减,上加下减,我这个函数由基础函数变完了,就是y=(m-1)%i+1,先向右,再向上嘛.</p> <p>想求得是什么,最终活着的肯定就1个,他的编号,此时是1,那么上一轮,他的编号是几呢,再上一轮呢,直到一开始,,他的编号是几呢??</p> <p>我们一点点推出这个公式.</p> <p>S=被干掉的位置,公式是S=(m-1)%i+1,左加右减上加下减.</p> <p>前一个号= (后-1+S)%i+1,左加右减上加下减.</p> <p>带入S后,这个公式的复杂度O(1).前=(后-1+(m-1)%i+1)%i+1 -&gt;前=(后+(m-1)%i)%i+1</p> <p>进一步优化,我们可以认为,m-1是k*i+r余数,%就相当于k=0,就是m-1 = r</p> <p>前=(后+r)%i+1-&gt;前=(后+m-1)%i+1</p> <h4 id="_14-4-91-first-missing-positive"><a href="#_14-4-91-first-missing-positive" class="header-anchor">#</a> 14-4-91-first-missing-positive</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35020&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/first-missing-positive/</p> <blockquote><p>几乎字节原题:非常难</p> <p>给定一个数组,正负0都可能有,给我返回最小的缺失的正整数.</p> <p>要求:时间复杂度O(N),额外空间复杂度O(1).</p> <p>杀死了用辅助工具的可能.Hash表,不能用,不能申请大结构.</p> <p>字节是求大于k的,所有数－个k,再求最早缺失的正整数,是不是一个题.!!</p></blockquote> <p>这个题,给定了n个数,要求O(N),那就只能遍历一遍数组拿下.</p> <p>我们想求一个东西,就是,假如说,6个数,我们就理想的认为,我们都能凑够,1~6,然后第一个丢掉的正整数是7.</p> <p>我们从2头看,假设,中间一坨,完全搞定了,然后一点点剔除,什么意思</p> <p>左右2个指针.LR,分别在0位置和N-1位置,我们假设的就是L~RN个数全部都在嘛,那N就是第一个缺失的.</p> <p>然后,我们干啥,我们既然认为每个位置的数都有,那我们就要让每个位置的数,都是i+1,也就是0位置是1,1位置是2.N-1位置是N,</p> <p>让指针开始移动了,先看看L位置的数,如果小于1,那么直接让他跟最后一个位置换,他不是我们要找的,那换完了R位置左移,我们只能找到N-1个数了,也就是我们找到任何一个不想要的,都是垃圾数字,都会让我的预期变小,都要换到最后,R左移,也就是R右边,都是垃圾区.R位置,就是我第一个缺失了的数.那么有多少种垃圾数字呢.</p> <ol><li>刚刚说的&lt;1 的,实际是小于等于L的,都已经有了,不要了.</li> <li>已经大于R的,不可能到这来了.</li> <li>没出现过,但是换过去后,发现他也是这个,重复了,我只要一个就行了,进入垃圾区.</li></ol> <p>直到L,R重叠,所有数,看完了,R位置,就是第一个凑不上的正整数</p> <h4 id="_17-2-104-返回最小的第k个数"><a href="#_17-2-104-返回最小的第k个数" class="header-anchor">#</a> 17-2-104-返回最小的第k个数.</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35033&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/</p> <blockquote><p>给定一个每一行有序、每一列也有序，整体可能无序的二维数组
在给定一个正数k，
返回二维数组中，最小的第k个数</p></blockquote> <p>这个题跟上一个题差不多,我们首先要知道,当我从右上角开始,求一个值,有多少个数,比我小??那么这个值,是什么?</p> <p>我们先看一下,右下角的是多少.假设1000.二分,我找500,看看,他有多少比我小.</p> <p>我右上角位置.出发,如果比我500大,我往左走,比我小,往下走,然后很快我就能用公式算出来,多少个比我小.</p> <p>如果我要求第300小的,结果比我500小的,有200个,一共1000个,那我知道,第300小的,值一定在500值到1000值之间.再二分.找750来一遍.</p> <p>发现比750小的有100个,那我知道,这个值一定在500~750值范围之间.</p> <p>注意,我们每次二分的时候,需要注意下,收集个数的同时,还需要记录这次搜索过程中最小的数,因为未必等于我二分的值.</p> <p>==当我算比我小的个数的时候,当比k小的时候,一定不是答案,当大于的时候,我先记录下这个答案,看看后续二分,有没有可能变得更小.==</p> <h4 id="_17-6-108后半部分50-17-多少个字符串对是回文问题"><a href="#_17-6-108后半部分50-17-多少个字符串对是回文问题" class="header-anchor">#</a> 17-6-108后半部分50:17-多少个字符串对是回文问题.</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35037&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/palindrome-pairs/</p> <blockquote><p>给一些个字符串,问其中哪些个字符串凑对,能组成回文的数量问题.</p></blockquote> <p>这个题,最好先去看下体系学习的manacher,更好的对你的回文加速有一个帮助.</p> <p>首先暴力解:每个字符串,两两凑一块,暴力嘛,N2,然后假设字符串平均长度,k,综合就是O(N^2*k).</p> <p>另一个解:</p> <p>我们拿到一个字符串,我们怎么搞,我们先看看,怎么他能变回文,</p> <p>如果他一个字符,那么我给后面的逆序加到前面,可以搞定,如果2个回文,那么后面一坨逆序加到前面,可以搞定.....直到字符串长度.我们可以完全逆序拼到后面.</p> <p>我们这个方案,需要注意,别算重复了</p> <p>另一个,就是,我需要给所有的字符串加到哈希表里,记录每个字符串所在的位置,便于快速找到逆序字符串,返回位置.</p> <p>这个复杂度多少呢?</p> <p>假设字符串长度k,判断回文,k,生成逆序,k,去哈希表查,==不是O(1)==,我这是字符串,不是内存地址,所以要先把字符串给哈希一个东西,才能继续去找,不能忽略,这个O(K).</p> <p>查询前缀是否回文,可以manacher加速为O(1),但是生成逆序,O(k)*查表O(k),时间复杂度O(K^2),然后,每个字符串走一遍.</p> <p>总代价,O(N * k^2),</p> <p>好的,两种方案,就要看数据量猜解法了:如果N大k小,就用第二种,如果k大,N小,就用第一种.</p> <h4 id="_19-1-116-lru算法"><a href="#_19-1-116-lru算法" class="header-anchor">#</a> 19-1-116-LRU算法</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35045&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/lru-cache/</p> <blockquote><p>一个缓存,当缓存满了的时候,按照最久不用的先淘汰,如何设计结构.</p></blockquote> <p>一个双端队列,一个哈希表,哈希表直接v的指针指着node,便于快速找到在双堆队列中的位置.</p> <p>当第一个k来的时候,建立节点,放到队列中,头尾指向null,当来个新的时候,挂在后面,假设容量就2,再来个就满了.好</p> <p>此时来个没来过的.那谁是最久的呢,队首的就是最早的,给他断掉,给新来的加到队尾.</p> <p>如果此时来了个是之前出现过的或者get了,那我直接给他断掉,接在队尾,这样他就最新了.</p> <p>总结==:双端队列+哈希表==</p> <h4 id="_19-1-117-lfu算法"><a href="#_19-1-117-lfu算法" class="header-anchor">#</a> 19-1-117-LFU算法</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35046&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/lfu-cache/</p> <blockquote><p>一个缓存,当缓存满了的时候,按照调用次数最少的先淘汰,相同调用次数的,最久不用的先淘汰,如何设计结构.</p></blockquote> <p>首先,假设,调用次数都一样的情况下,淘汰最久的,我们搞过了,就是LRU,一个双端队列.</p> <p>其实一样的,只是规则不一样,一个是根据时间,一个是根据次数,不就是套一起吗?就算再来更多维度一样的.</p> <p>就是2个双端队列,一个用于记录调用次数的,次数里面是相同次数下,时间轴的k的.</p> <p>淘汰逻辑就是,先找调用次数的数组的头,然后,里面找到一个双端队列,淘汰这个里面的头,</p> <p>更新或get逻辑:先找到他的位置,断掉.如果次数的队列都空了,连这个次数的队列这个整个的容器都断掉!然后找到对应的容器,取出队列,加进去.</p> <h4 id="_24-1-140-返回第k的数值对"><a href="#_24-1-140-返回第k的数值对" class="header-anchor">#</a> 24-1-140-返回第k的数值对</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35069&amp;courseVersionId=1348</p> <blockquote><p>长度为N的数组arr，一定可以组成N^2个数字对
例如arr = [3,1,2]，数字对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)
也就是任意两个数都可以，而且自己和自己也算数字对
数字对怎么排序？
第一维数据从小到大；第一维数据一样的，第二维数组也从小到大
所以上面的数值对排序的结果为：(1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)
给定一个数组arr，和整数k，返回第k小的数值对</p></blockquote> <p>按照第一维开始排序,第二维也从小到大排序.</p> <p>排序后,我们知道整个数值对数组的长度,假设是M,那么以1开头的,假设2个1,那是不是2M个1开头的数,这是前2M个最小的数,因为1开头的嘛.</p> <p>然后,假设M=20,1开头的2个,那就是40个数1开头,假设求第55小的数.那么我知道肯定不是1开头的数,找到下一个开头的数,看看他有多少个,假设,两个2,那这2开头的又40个,40+40超了55了.所以他在哪呢.在第一个2加上第15个数值对的第2位数字.</p> <h4 id="_24-3-142-整数数组-返回分成4个不同部分-每个部分累加和相同的问题"><a href="#_24-3-142-整数数组-返回分成4个不同部分-每个部分累加和相同的问题" class="header-anchor">#</a> 24-3-142-整数数组,返回分成4个不同部分,每个部分累加和相同的问题.</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35071&amp;courseVersionId=1348</p> <p>搞一个前缀和,从左到右,i位置做第一刀,看看行不行,累加和干掉当前值,因为砍掉了,</p> <p>然后去前缀和里找,我前面的是temp,那找个<code>temp*2+我的值</code>,一定得有,否则他当不了第一刀,找到了,那这个位置下一个就是第二刀,找<code>temp*3+第一刀+第二刀</code>,一定得有.直到砍了3刀,结尾位置=<code>temp*4+第一刀+第二刀+第三刀的值</code>.</p> <h4 id="_24-4-143-至少有多少种颜色可以完成任务"><a href="#_24-4-143-至少有多少种颜色可以完成任务" class="header-anchor">#</a> 24-4-143 -至少有多少种颜色可以完成任务</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35072&amp;courseVersionId=1348</p> <blockquote><p>N * M的棋盘（N和M是输入参数）
每种颜色的格子数必须相同的
上下左右的格子算相邻
相邻格子染的颜色必须不同
所有格子必须染色
返回至少多少种颜色可以完成任务</p></blockquote> <p>暴力方法,观察规律,写出解.</p> <p>从2种方法开始,最多N*M种颜色,</p> <p>一个是N*M必须整除i,另一个是暴力方法可以验证能填上.</p> <p>发现,结果是N*M的最小质数因子.</p> <p>怎么来的,不关心,不知道,论证太长看不懂不管.</p> <h4 id="_25-3-148-max-points-on-a-line"><a href="#_25-3-148-max-points-on-a-line" class="header-anchor">#</a> 25-3-148-max-points-on-a-line</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35077&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/max-points-on-a-line/</p> <blockquote><p>给定一个二维数组,代表一些点,求画一条线的话,最多能罩住多少个点.</p></blockquote> <p>每一个点为起点,和他后面的点化一条线,为什么前面的不用画?因为答案如果在前面的点,那前面的点已经和他连过了.</p> <p>画一条线,有几种可能</p> <ol><li>同一个点,共点</li> <li>垂直线</li> <li>水平线</li> <li>普通的斜率线</li></ol> <p>普通斜率怎么表示??</p> <p>不能HashMap&lt;double,int&gt;,因为会有精度耗损.所以,用分数表示,2/5和20/50怎么约.</p> <p>求公约数,不会就背住就完事了.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> b <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">?</span>a<span class="token operator">:</span><span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token operator">%</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>能约了,我们用Map&lt;Integer,Map&lt;Integer,Integer&gt;&gt;来表示,2,{5,6}代表2/5斜率上有6个点.每遇到同一个斜率的,就加一个点.</p> <p>每次走的过程中,收集上面4中情况,</p> <p>每次比对,上次的result和此次max(2,3,4)+共点 的max返回</p> <h4 id="_28-2-160-stringtointeger"><a href="#_28-2-160-stringtointeger" class="header-anchor">#</a> 28-2-160-StringToInteger</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35089&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/string-to-integer-atoi/</p> <blockquote><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）
函数 myAtoi(string s) 的算法如下：
读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，&quot;123&quot; -&gt; 123， &quot;0032&quot; -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为231 − 1。
返回整数作为最终结果。
注意：本题中的空白字符只包括空格字符 ' ' 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</p></blockquote> <p>我们这么干,字符串一个个字符往下走,只要他是数字,就给他转数字,往下接,如果中途溢出了,就返回-1或者抛出异常.</p> <p>我们用负数接,为什么,因为,负数的绝对值,比正数大,所以更安全.</p> <p>比如就给你个&quot;-2147483647&quot;,他是不是不溢出,但是你用正数接,他就溢出了!!!!!!!!</p> <p>判断字符串的开头,&quot;-&quot;开头,就记录一个状态是负数,否则不是负数.然后继续往下撸数字.</p> <p>既然用负数接,那我就用'0'的Ascii码减去当前遍历到的字符的....捞一下.,'0'的ascii码int值为48,付一个码表网址https://www.jyshare.com/front-end/6318/</p> <p>然后 乘10 + 当前值,注意考虑溢出,乘完了可能溢出了.如果小于系统最小/10,那会溢出了!.等于呢,不一定,因为是正数,个位数是0,要考虑+cur是否溢出.膜一下,然后比一下.</p> <h4 id="_28-3-161-integertoroman"><a href="#_28-3-161-integertoroman" class="header-anchor">#</a> 28-3-161-IntegerToRoman</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35090&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/integer-to-roman/</p> <blockquote><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给你一个整数，将其转为罗马数字</p></blockquote> <p>我们给这个数字,从高位往下,求最高位数组,例如,3007.先/1000再%10,剩余3,对应MMM,我们可以做一个二维数组,1维度指代位数,二维度指代到9.</p> <p>例如<code>nums[3][3]</code>,代表千位是3,对应的是MMM,直接就拿到了这个MMM.</p> <p>然后百位,十位,各位,都拿到,依次拼接起来.</p> <h4 id="_28-4-162-romantointeger"><a href="#_28-4-162-romantointeger" class="header-anchor">#</a> 28-4-162-RomanToInteger</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35091&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/roman-to-integer/</p> <blockquote><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4
同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p></blockquote> <p>我们要知道罗马数字的规则,如果前面的比后面的一个小,那说明前面的是负数 ,否则后面的比前面的小,就是正数.</p> <p>我们重新做一个数组,跟罗马数组一样长,将字符转换为阿拉伯数字.</p> <p>然后我们遍历这个数组,如果后面的比前面的大,当前就是负数,否则当前就是正数,sum=所有的数累加起来.</p> <h4 id="_28-6-164-letter-combinations-of-a-phone-number"><a href="#_28-6-164-letter-combinations-of-a-phone-number" class="header-anchor">#</a> 28-6-164-letter-combinations-of-a-phone-number/</h4> <p>https://leetcode.com/problems/letter-combinations-of-a-phone-number/</p> <blockquote><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
按键2对应：'a', 'b', 'c'
按键3对应：'d', 'e', 'f'
按键4对应：'g', 'h', 'i'
按键5对应：'j', 'k', 'l'
按键6对应：'m', 'n', 'o'
按键7对应：'p', 'q', 'r', 's'
按键8对应：'t', 'u', 'v'
按键9对应：'w', 'x', 'y', 'z'
示例 1：
输入：digits = &quot;23&quot;
输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]
示例 2：
输入：digits = &quot;&quot;
输出：[]
示例 3：
输入：digits = &quot;2&quot;
输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</p></blockquote> <p>这个就是个深度优先遍历,当前选一个,递归下去,比较简单的深度优先遍历题目.</p> <p>带着一个path往下走,path代表0~index-1位置搞完了的记录,用来帮我收集答案用的.</p> <p>path每次遍历当前号吗的下一个字符的时候,覆盖当前字符.然后带着path下去.</p> <p>==深度优先遍历必须要写熟==</p> <h4 id="_28-7-165-remove-nth-node-from-end-of-list"><a href="#_28-7-165-remove-nth-node-from-end-of-list" class="header-anchor">#</a> 28-7-165-remove-nth-node-from-end-of-list</h4> <p>https://leetcode.com/problems/remove-nth-node-from-end-of-list/</p> <blockquote><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？</p></blockquote> <p>两个指针,第一个指针先走,走到n个节点了,第二个指针跟着走,第一个指针到结尾时候,第二个指针就是倒数n个节点,找到他的上一个,下一个,断开,重连,所以,开始的数量,不是n,是n+1.然后找打位置后,和+2位置连起来.</p> <h4 id="_28-8-166-valid-parentheses"><a href="#_28-8-166-valid-parentheses" class="header-anchor">#</a> 28-8-166-valid-parentheses/</h4> <p>https://leetcode.com/problems/valid-parentheses/</p> <blockquote><p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。</p></blockquote> <p>用栈.主流程如下:</p> <p>遇到左括号,就压栈,遇到右括号,就弹出栈一个左括号,如果这个当前遇到的右括号和弹出的左括号配上了,就继续遍历,否则,肯定是出错了返回false.</p> <p>处理边界条件</p> <ul><li>如果,遇到一个右,但是栈里面没东西,那也是不对的,说明右括号多了</li> <li>如果,遍历完了,栈里面还有东西,说明左括号多了,也是不对的.</li></ul> <p>栈,可以用数组替代.char[],</p> <p>但是记住如果数组范围不大的情况下,才可以用数组替代.我们想做什么,是想让值来做位置,然后让类型,代表的东西代表背后的东西.</p> <p>例如,词频,我们有2个值,17出现3次,20亿出现2次.只有2个值!,却要开辟数组的长度要20亿,</p> <p>这样就不如用HashMap来装,2个长度就够了</p> <p>基本机构的,常数时间更好.</p> <h4 id="_28-9-167-创建包含n个左括号的所有合法的括号组合"><a href="#_28-9-167-创建包含n个左括号的所有合法的括号组合" class="header-anchor">#</a> 28-9-167-创建包含n个左括号的所有合法的括号组合</h4> <p>https://leetcode.com/problems/generate-parentheses/</p> <blockquote><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。
示例 1：
输入：n = 3
输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]
示例 2：
输入：n = 1
输出：[&quot;()&quot;]</p></blockquote> <p>这个题,收集答案,那就是一个深度优先遍历.</p> <p>我先做一个决定,当前index,用左还是右!!.然后接着往下走,做下一个决定.</p> <p>重要优化就是剪枝,我第一步就发现错了,还需要继续做决定吗?明显不需要.</p> <p>那么可以剪枝的方法有多少呢?</p> <p>我们要知道,怎么判断括号是否合法,那就是,中间过程任何情况下,左括号多于右括号,直到最后补齐有括号.</p> <p>所以我们需要2个变量,一个是leftMinusRight,左减右剩余数量,一个是leftRest,左括号剩余.</p> <p>有leftRest我才能放左括号,中间过程中,我可以左括号比右扩号多</p> <p>有leftRest我也可以放右,但是有leftMinusRight我才能放右括号.否则放置就会右括号多,直接错</p> <p>这样,我收集到basecase,index到达数组结尾,代表我中间放置的都是对的,不然到不了,收集path中的答案.path是深度优先遍历中的老演员了.走过一个分支后,覆盖当前分支最后一个字符,继续向下.</p> <h4 id="_28-10-168-remove-duplicates-from-sorted-array"><a href="#_28-10-168-remove-duplicates-from-sorted-array" class="header-anchor">#</a> 28-10-168-remove-duplicates-from-sorted-array/</h4> <p>https://leetcode.com/problems/remove-duplicates-from-sorted-array/</p> <blockquote><p>给你一个==有序==数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
示例 1：
输入：nums = [1,1,2]
输出：2, nums = [1,2,<em>]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4,</em>,<em>,</em>,<em>,</em>]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p></blockquote> <p>两个指针,当前数cur,填到哪指针fill,</p> <p>cur,fill从0开始,cur开始走,cur!=fill,fill的值拷贝到cur的下一个,fill跳下一个,</p> <p>不相等就拷贝然后fill跳,相等就,cur自己跳.直到cur自己跳到了数组的结尾了,结束.</p> <h4 id="_28-12-170-valid-sudoku-数独1-验证已填的数据是否合理"><a href="#_28-12-170-valid-sudoku-数独1-验证已填的数据是否合理" class="header-anchor">#</a> 28-12-170-valid-sudoku/ 数独1-验证已填的数据是否合理</h4> <p>https://leetcode.com/problems/valid-sudoku/</p> <blockquote><p>请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。
注意：
一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。</p></blockquote> <p>三个指标,行,列,桶.都ok则ok</p> <p>我们用二维数组来表示,例如,行0-9行,1-9的数是否出现过.同样的还有列,桶,<code>col[][],bucket[][]</code>,第一维是行列桶值,第二维代表数是否出现.</p> <p><code>boolean[][] row = new boolean[9][10]</code>:例如<code>row[0][3]</code>代表第0行,3这个数是否出现过,第二维度,0我们是不用的,空着.</p> <p>遍历所有的格子,重点是,桶的信息,怎么通过行列获取到,在哪个桶里.<code>int bid = 3 * (i/3) +(j/3)</code>.获取桶号.</p> <p>如果当前位置不是'.',那我就要验证了,如果行,列,桶有任何一个,已经出现了,那就是false了,否则标记当前位置.</p> <h4 id="_28-13-171-sudoku-solver-数独2-填写完整数独"><a href="#_28-13-171-sudoku-solver-数独2-填写完整数独" class="header-anchor">#</a> 28-13-171-sudoku-solver/ 数独2-填写完整数独.</h4> <p>https://leetcode.com/problems/sudoku-solver/</p> <blockquote><p>编写一个程序，通过填充空格来解决数独问题。
数独的解法需遵循如下规则：
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次
数独部分空格内已填入了数字，空白格用 '.' 表示。</p></blockquote> <p>填写数独,返回所有结果.</p> <p>看到返回所有结果,就是深度优先遍历了.写个递归.</p> <p>先扫一遍棋盘上面的数字,做三个二维验证数组记录下来.</p> <p>然后每个位置做决定,试试1~9能不能填,记录结果,往下跳.</p> <p>process,来到i,j位置,有了,就跳下一个,如果没有数,试试1~9能不能填,但是不能和三个二维验证数组冲突.</p> <p>一般这种深度优先遍历,basecase都是ij某一个越界的时候,这时候代表之前的,决定都对,剪枝都没给我减掉.return true,</p> <p>返回后,调用处设置下一个现场,继续深度优先遍历.</p> <p>收集答案后,一般需要回复现场</p> <p>==棋盘遍历方法==,<code>int nexti = j!=j的边界? i:i+1; int nextj = j!=j的边界?j+1:0</code></p> <h4 id="_28-14-172-count-and-say"><a href="#_28-14-172-count-and-say" class="header-anchor">#</a> 28-14-172-count-and-say/</h4> <p>https://leetcode.com/problems/count-and-say/</p> <p>这是一个纯阅读理解题,+coding题,完全不是算法题,没啥意思</p> <blockquote><p>给定一个正整数 n ，输出的第 n 项。
前五项如下：</p> <ol><li><div class="language- extra-class"><pre><code>1
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>11
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>21
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>1211
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>111221
</code></pre></div></li></ol> <p>第一项是数字 1
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot;
返回第N项的字符串</p></blockquote> <p>写一个递归,basecase是n&lt;1或者等于1的时候,否则,递归下去,想知道n,需要先知道n-1,想知道n-1,需要n-2......</p> <h4 id="_28-15-172-group-anagrams"><a href="#_28-15-172-group-anagrams" class="header-anchor">#</a> 28-15-172-group-anagrams/</h4> <p>https://leetcode.com/problems/group-anagrams/</p> <blockquote><p>给定一个字符串数组，将字母异位词组合在一起。可以按任意顺序返回结果列表。
字母异位词指字母相同，但排列不同的字符串。
示例 1:
输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]
输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]
示例 2:
输入: strs = [&quot;&quot;]
输出: [[&quot;&quot;]]
示例 3:
输入: strs = [&quot;a&quot;]
输出: [[&quot;a&quot;]]</p></blockquote> <p>这个题,我们遍历这个字符串数组,给每个字符转成char,然后按照字母顺序排序,再转回string,放到map中,key是转之后的,val是遍历的原串,val是<code>List&lt;String&gt;</code>格式的.</p> <p>最后按照map.getValues(),收集答案返回即可</p> <p>如果字符串&quot;词频&quot;都不长,例如a~z26种,我们也可以遍历字符串,统计词频,做一个&quot;1_0_2_4&quot;这样的词频字符串.代表,a2个,b0个,c2个,d4个的字符串,然后把字符串词频相同的收集到一起.</p> <h4 id="_29-5-177-unique-paths"><a href="#_29-5-177-unique-paths" class="header-anchor">#</a> 29-5-177-unique-paths/</h4> <p>https://leetcode.com/problems/unique-paths/</p> <blockquote><p>一个机器人位于一个 m x n 网格的左上角
机器人每次只能向下或者向右移动一步
机器人试图达到网格的右下角
问总共有多少条不同的路径？</p></blockquote> <p>这个不用动态规划,是因为他可以往下或者右,不需要收集东西,</p> <p>所以理论是个数学题.C上n下m=m!/n!*(m-n)! n为右上角,m为右下角</p> <p>指的是组合数的运算。组合数用于计算从m个元素中选择n个元素的组合方式的数量</p> <p>例如5*6的格子.左上到右下,需要9步,右面最多5步,下面最多4步.排列组合,</p> <p>中间如果太大的话,可能溢出,所以,最好是约一下,然后再算.虽然最终依然可能溢出,但是能尽可能的,算更多的数.</p> <p>最大公约数算法:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">long</span> m<span class="token punctuation">,</span><span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> m <span class="token operator">:</span> <span class="token function">gcd</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token operator">%</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="/assets/img/1725768409796.7a380c3f.jpg" alt=""></p> <p>从i从right位置,j从1位置开始,,i++,j++,i&lt;all,都乘进去,期间,注意约一下,然后再继续乘,这样避免本来能算的值就提前溢出的情况.</p> <h4 id="_29-6-178-plus-one"><a href="#_29-6-178-plus-one" class="header-anchor">#</a> 29-6-178-plus-one/</h4> <p>https://leetcode.com/problems/plus-one/</p> <blockquote><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加1
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字
你可以假设除了整数 0 之外，这个整数不会以零开头
示例 1：
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
示例 2：
输入：digits = [9,9,9]
输出：[1,0,0,0]
解释：输入数组表示数字 1000。
示例 3：
输入：digits = [0]
输出：[1]</p></blockquote> <p>什么时候需要进位,需要数组重造,一定是,全部都是9的时候,但凡一位不是9,就不需要进位.</p> <p>数组最后一个加个1嘛.从n-1,这个低位,开始计算.只要&lt;9,算完了直接返回,如果算到最后了,都没返回,说明,有进位了,全进位了,(有进位当前位设置0.)那重造一个数组,长度为n+1,第一位设置1,返回即可,其他的默认都是0.</p> <h4 id="_29-8-180-炸弹人"><a href="#_29-8-180-炸弹人" class="header-anchor">#</a> 29-8-180-炸弹人</h4> <p>https://leetcode.com/problems/set-matrix-zeroes/</p> <blockquote><p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
进阶：
一个直观的解决方案是使用 O(m * n) 的额外空间，但这并不是一个好的解决方案。
一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
你能想出一个仅使用常量空间的解决方案吗？</p></blockquote> <p>如果是m*n的额外空间,我遍历1遍,记录每个0的位置,然后根据这些位置,来设置他们所在行列的状态.</p> <p>如果是m+n.两个boolean类型的数组,我用第一行列记录哪些行列是否一会要变成0.</p> <p>如果是2个变量,一个记录第一行,一个记录第一列,一会是否要变成0,从<code>i==1,j==1</code>开始遍历,中间的是否要变化,==直接用原数组的第一行列来记录,不额外开辟空间.==</p> <p>如果用1个变量,用左上角的格子,代表第一行是否变0,而不再代表列是否变,一个变量,为0列是否变0.先遍历下0列可以得出.</p> <p>然后从0行,1列开始遍历.如果第一行某个值为0,左上角也改成0,剩下的都原数组替代.</p> <h4 id="_30-1-182-棋盘找一个单词"><a href="#_30-1-182-棋盘找一个单词" class="header-anchor">#</a> 30-1-182-棋盘找一个单词</h4> <p>https://leetcode.com/problems/word-search/</p> <blockquote><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p></blockquote> <p>这就是一个深度优先遍历,</p> <p>basecase就是,数组到了越界为止了,返回true,因为代表剪枝没干掉我,我走的每一步都对.</p> <p>当前走到了越界为止,return false;</p> <p>制造一个现场,代表我当前做的决定,然后带着决定,深度优先遍历,</p> <p>然后调用方恢复现场,继续返回.</p> <h4 id="_30-8-188-杨辉三角形"><a href="#_30-8-188-杨辉三角形" class="header-anchor">#</a> 30-8-188-杨辉三角形</h4> <p>https://leetcode.com/problems/pascals-triangle/</p> <blockquote><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p></blockquote> <p>这个东西你不能那他当等腰三角形看,你得把他第一列对齐,然后你会发现,多出来的,一定是1,否则就等于上面的加左上的.</p> <p>每行收集下来,不就完事了吗</p> <h4 id="_30-8-188-杨辉三角形2"><a href="#_30-8-188-杨辉三角形2" class="header-anchor">#</a> 30-8-188-杨辉三角形2</h4> <blockquote><p>给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
你可以优化你的算法到 O(1) 空间复杂度吗？
Leetcode题目 : https://leetcode.com/problems/pascals-triangle-ii/</p></blockquote> <p>返回值,不算额外空间复杂度.!</p> <p>我们是不是能根据多少行,提前知道这一行有多少个,我先初始化出来,然后.自我更新,这不算开辟了额外的空间.</p> <p>某一行,我们从后往前更新,我们需要上面的加左上的.</p> <p>最后,每行末尾加个1.</p> <h4 id="_30-9-189-binary-tree-maximum-path-sum"><a href="#_30-9-189-binary-tree-maximum-path-sum" class="header-anchor">#</a> 30-9-189-binary-tree-maximum-path-sum/</h4> <p>https://leetcode.com/problems/binary-tree-maximum-path-sum/</p> <blockquote><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和。
进阶：
如果返回最大路径和上的所有节点，该怎么做？</p></blockquote> <h2 id="二分答案法"><a href="#二分答案法" class="header-anchor">#</a> 二分答案法</h2> <p>二分法,国内外都很爱考.</p> <h4 id="心得-2"><a href="#心得-2" class="header-anchor">#</a> 心得:</h4> <ol><li><p>找到单调性!!!只要有单调性的,都能二分.</p></li> <li><p>一般的能快速联想到二分的就是,定一个目标,问问条件够不够.</p></li></ol> <h4 id="来自华为-工人吃大力丸问题"><a href="#来自华为-工人吃大力丸问题" class="header-anchor">#</a> 来自华为,工人吃大力丸问题.</h4> <p>https://www.bilibili.com/video/BV16o4y1c77G?p=4&amp;spm_id_from=pageDriver&amp;vd_source=aa2ca96f997833d2dcbb3cf9f4cd33ac</p> <blockquote><p>来自华为
给你 n个任务和 m 个工人</p> <p>每个任务需要一定的力量值才能完成</p> <p>需要的力量值保存在下标从 0 开始的整数数组 tasks 中</p> <p>第 1 个任务需要 tasks[i]的力量才能完成</p> <p>每个工人的力量值保存在下标从 0 开始的整数数组 workers 中</p> <p>第j个工人的力量值为 workers[j]
每个工人只能完成 一个 任务且力量值需要 大于等于该任务的力量要求值，即 workers[j&gt;m tasks[i]</p> <p>除此以外，你还有 pills 个神奇药丸</p> <p>可以给 一个工人的力量值 增加 strength</p> <p>你可以决定给哪些工人使用药丸</p> <p>但每个工人 最多 只能使用 一片 药丸</p> <p>给你下标从 8开始的整数数组tasks 和 workers 以及</p> <p>两个整数 pills 和 strength ，请你返回 最多 有多少个任务可以被完成。</p> <p>测试链接:https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/</p></blockquote> <p>这个题,有两个解法,</p> <ol><li><p>二分法</p></li> <li><p>自定义窗口结构法.</p></li></ol> <h4 id="_9-5-62-判断一个数字-是不是某个数的step-sum"><a href="#_9-5-62-判断一个数字-是不是某个数的step-sum" class="header-anchor">#</a> 9-5-62 判断一个数字,是不是某个数的step sum</h4> <blockquote><p>定义何为step sum？
比如680，680 + 68 + 6 = 754，680的step sum叫754
给定一个正数num，判断它是不是某个数的step sum</p></blockquote> <p>这个题,乍一看,位运算,一个公式,倒着就能退出来,但是,你恐怕是要定义一堆的double类型的变量吧.</p> <p>实际上,这个题可以二分,我们发现了一个单调性!!</p> <p>一个小的数,他的step sum,一定没有更大的数的step sum大,例如,238的step sum一定没有429的step sum大,这就是单调性.</p> <p>所以,这个题,我们二分查找,先试试从0到他,能不能凑出来,如果不能,往两边走,如果最后都试了,都不行,那肯定不是,否则,我们logN的代价即可找到这个数.其实严谨来说,我们求步骤和,也是有代价的,那就是数的长度,假设是x,那就是log10为底,x,总体复杂度,加一起,很低!!</p> <h4 id="_12-2-79-两个有序数组-求合并后第k小个上中位数"><a href="#_12-2-79-两个有序数组-求合并后第k小个上中位数" class="header-anchor">#</a> 12-2-79 两个有序数组,求合并后第k小个上中位数.</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35008&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/median-of-two-sorted-arrays/description/</p> <blockquote><p>上面说的是原题,</p> <p>进阶问题：
在两个都有序的数组中找整体第K小的数
可以做到O(log(Min(M,N)))</p></blockquote> <p>逆天时间复杂度.如果等长,O(logN).如果不等长,O(log Min(M,N))</p> <p>这个题,不关注具体的值的内容,我们只需要知道有序,知道下标对应关系即可.</p> <p>等长:求上中位数</p> <p><img src="/assets/img/WechatIMG35.fe8f3f32.jpg" alt=""></p> <p>不等长,求第k小</p> <p><img src="/assets/img/WechatIMG36.34ee4ea2.jpg" alt=""></p> <h4 id="_28-11-169-find-first-and-last-position-of-element-in-sorted-array"><a href="#_28-11-169-find-first-and-last-position-of-element-in-sorted-array" class="header-anchor">#</a> 28-11-169-find-first-and-last-position-of-element-in-sorted-array</h4> <p>https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/</p> <blockquote><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
要求：设计并实现时间复杂度为 O(log n) 的算法</p></blockquote> <p>有序,找一个值,二分,</p> <p>我们之前学过一个方法,叫==&quot;找到小于某个数的最右位置&quot;==,是能做到logN的,</p> <p>假如一个数组,找7的左右位置,我先调用这个方法找小于7的最右位置,这个位置的下一个位置,不等于7,则没有7.</p> <p>如果找到了7,那找小于8的最右位置.这不就找到了7的左右位置了吗.</p> <p>找到小于某个数的最右位置{</p> <p>二分,只要m值小于target,记录一个临时答案,然后往右侧找,直到L&gt;R,</p> <p>}</p> <h4 id="_29-1-173-search-in-rotated-sorted-array"><a href="#_29-1-173-search-in-rotated-sorted-array" class="header-anchor">#</a> 29-1-173-search-in-rotated-sorted-array/</h4> <p>https://leetcode.com/problems/search-in-rotated-sorted-array/</p> <blockquote><p>整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，
使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数
例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p></blockquote> <p>二分,L,M,R,</p> <p>如果M等于target了,返回,否则继续讨论</p> <p>无重复时候,</p> <p>很简单,这种情况,总能二分.通过LMR来判断,断点在哪,答案在哪个部分上,继续二分.</p> <p>有重复的时候,</p> <p><code>L==M==R</code>我们不知道从哪里转了.例如12222222222,再中间某个地方切了转了,不知道切在哪里的</p> <p>所以我们这种情况,只能让L++,直到L位置到M为止,或者中间某个位置,我们再M~R继续二分.LMR不完全相等了</p> <p>当LMR不完全相等时候,可以二分.</p> <p>如果,L!=M的数,如果L&lt;M的数,则断点不可能在L~M之间,断点一定在M~R上,如果我找到值在LM之间,直接二分找即可.</p> <p>如果target在有断点那部分, 重新二分,判断LMR的关系.</p> <p>这个题重点难点就是,当前情况,二分后,怎么通过LMR来判断断点在哪里,然后答案所在的半边,到底在哪半边.</p> <h4 id="_29-2-174-pow"><a href="#_29-2-174-pow" class="header-anchor">#</a> 29-2-174-Pow</h4> <p>https://leetcode.com/problems/powx-n/</p> <blockquote><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数</p> <p>有可能是负数</p></blockquote> <p>我们先说,计算一个整数的n次方,怎么算的最快.</p> <p>例如,10^75,最慢的就是10乘个75次,</p> <p>但是我们可以二分,怎么做,75的二进制,1个64+0个32+0个16+1个8+0个4+1个2+1个1.</p> <p>所以啊,你看10^1,我是否需要,需要就乘进去,10^2,我需要吗,需要就乘进去,10^4,不需要不要,10^8,需要就乘进去,^16/32都不需要,不乘,</p> <p>10^64,乘进去.一共,乘了4次.</p> <p>这个判断需不需要,我们让他&amp;1,如果不是0,说明最后一位是1,需要,然后右移,继续&amp;1,是0,则不需要,</p> <p>种子如何增长,我不管,我每次都乘自己,谁需要这个种子时候,就乘进去.10^1初始,然后乘自己,10^2,然后乘自己10^4,10^8,10^16,10^32,10^64.......</p> <p>logN可以搞定</p> <p>再回来说这个题,可能是负数,那就是整数,最后1/这个结果,就是了.但是有个特殊的.系统最小值,他转不成正数.</p> <p>所以遇到他,我单独处理下,前面转绝对值时候,先让他+1,然后后面1/这个值的时候,单独乘一个x.搞定.</p> <h4 id="_29-7-179-开根号"><a href="#_29-7-179-开根号" class="header-anchor">#</a> 29-7-179-开根号</h4> <p>https://leetcode.com/problems/sqrtx/</p> <blockquote><p>实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
示例 1:
输入: 4
输出: 2
示例 2:
输入: 8
输出: 2
说明: 8 的平方根是 2.82842...，由于返回类型是整数，小数部分将被舍去。</p></blockquote> <p>在1~x范围二分,每次相乘,如果,&gt;向左二分,否则向右二分.</p> <p>basecase:x==0 返回0,x&lt;3返回1,</p> <p>加强版,如果是开完了根号要小数呢?再给个k参数.保留k位小数.</p> <p>例如10,保留4位,</p> <p>那我们首先,确定,一定是3.几,那就是在3.0000到3.9999之间嘛.</p> <p>二分被.相当于0到9999之间二分,例如,分到500了,那我是算什么呢,3.0500*3.0500是否大于0,决定继续二分.</p> <h2 id="窗口问题"><a href="#窗口问题" class="header-anchor">#</a> 窗口问题</h2> <h4 id="心得-3"><a href="#心得-3" class="header-anchor">#</a> 心得:</h4> <ol><li>单调性才是最重要的,找到了单调性,什么二分,什么窗口,什么双指针,只是手段.最重要的,就是单调性!!.</li></ol> <h4 id="一维接雨水问题"><a href="#一维接雨水问题" class="header-anchor">#</a> 一维接雨水问题</h4> <p>https://www.bilibili.com/video/BV16o4y1c77G?p=180&amp;vd_source=aa2ca96f997833d2dcbb3cf9f4cd33ac</p> <blockquote><p>给定一个数组,你可以想象为一些柱状图,其中凹陷的位置,可以接住雨水,问,这个数组,最多能接住多少雨水.例如,<code>[3,1,3]</code>,中间的1能接住2个雨水,返回2.<code>[2,1,3,1,4]</code>,能接住1+2=3个水.第一个1能接住1个,再多会从左边溜走,第二个1能接住2个,再多会从左边的3溜走.</p></blockquote> <p>最优解:一个窗口,从左右往中间缩,哪边小,哪边开始缩,如果一边小,则两边可以同时缩,缩的时候,计算缩的位置的存水量,取值范围是,min(左窗口值,右窗口值)-自身的高度,如果为负数,储水量为0.一个个加完了,就是结果值</p> <h4 id="_8-3-50盛最多水的容器"><a href="#_8-3-50盛最多水的容器" class="header-anchor">#</a> 8-3-50盛最多水的容器</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=52250&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/container-with-most-water/</p> <blockquote><p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>ith</code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p> <p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p> <p>Return <em>the maximum amount of water a container can store</em>.</p> <p><strong>Notice</strong> that you may not slant the container.</p></blockquote> <p>这个题,和上面的一维接雨水一样,我就一个双指针,那边小开始缩那边,缩之前,结算水量,矮的那边是瓶颈.</p> <p>我们不去严格的纠结每个位置的准确水量,我们只考虑,有没有那个位置能推高水量,这个答案如果存在,他一定能被推高.</p> <p>我们从外,一直往里面缩,答案必在其中,一样大的时候,选谁先缩小都行,就看能不能推高答案.</p> <p>这个题,背住就行了.</p> <h4 id="双数组同时达标问题"><a href="#双数组同时达标问题" class="header-anchor">#</a> 双数组同时达标问题</h4> <p>https://www.bilibili.com/video/BV16o4y1c77G?p=6&amp;vd_source=aa2ca96f997833d2dcbb3cf9f4cd33ac</p> <blockquote><p>来自微众银行
给出两个长度均为n的数组
A={ a1, a2,..  ,an}</p> <p>B={ b1,b2,... ,bn }.
你需要求出其有多少个区间[L,R]满足:</p> <p>数组A中下标在[L,R]中的元素之和在[La,Ra]之中</p> <p>数组B中下标在[L,R]中的元素之和在[Lb,Rb]之中</p> <p>输入
第一行有一个正整数N(1&lt;=N&lt;=100000)，代表两个数组的长度.</p> <p>第二行有N个非负整数，范国在0到1000000000之间，代表数组中的元素,10的8次方</p> <p>第三行有N个非负整数，范国在0到1000000000之间，代表数组中的元素。</p> <p>第四行有4个整数La,Ra,Lb,Rb，范围在0到10^18之间，代表题目描述中的参数。</p> <p>输出
一个整数，代表所求的答案。</p></blockquote> <p>这个问题,数据量这么大,任何N✖️的方法,一定过不了,所以,最多就是O(N),过一遍数组就完事.!</p> <p>非负数,数越多,那么范围一定越大!!,这就是==,单调性!!!==,我们发现了单调性,就可以整活了.窗口过遍,我们找到以i位置开始,同时符合a的(小窗口范围WindowsAR1,大窗口WindowsAR2),b的达标区间((小窗口范围WindowsBR1,大窗口WindowsBR2))的交集,交集有多少个,那么,就有多少个答案,O(N),因为窗口不回退!!</p> <h4 id="_12-1-78-字符串中找到一个长度为m的连续子串"><a href="#_12-1-78-字符串中找到一个长度为m的连续子串" class="header-anchor">#</a> 12-1-78-字符串中找到一个长度为m的连续子串,</h4> <blockquote><p>给定长度为m的字符串aim，以及一个长度为n的字符串str
问能否在str中找到一个长度为m的连续子串，
使得这个子串刚好由aim的m个字符组成，顺序无所谓，
返回任意满足条件的一个子串的起始位置，未找到返回-1</p></blockquote> <p>启示:</p> <ul><li>求摘要的,多半是需要词频统计!int[256]来处理.</li> <li>如果是某一段的,那就搞一个窗口.为词频统计的总长,在这个窗口内,统计词频,然后比较.</li></ul> <p>首先,我们要知道aim的长度,这个值,要作为窗口的,同时收集字符频次,用int[256]即可.不用map,和字符频次总count</p> <p>我们用这个窗口,滑过str,收集信息</p> <p>进来的时候,字符频次只要大于0,就词频-1,count-1,如果词频已经&lt;=0了,count不减.</p> <p>字符出窗口的时候,只要是结果大于0,就词频+1,count+1,如果词频还是&lt;=0了,count不加.</p> <p>什么时候,调整完了窗口,count为0,则代表找到了一个能组成的字符,如果越界了,也不为0,则返回-1.</p> <h4 id="_24-5-144-最短包含子串"><a href="#_24-5-144-最短包含子串" class="header-anchor">#</a> 24-5-144-最短包含子串</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35073&amp;courseVersionId=1348</p> <blockquote><p>给定两个字符串str1和str2
在str1中寻找一个最短子串，能包含str2的所有字符
字符顺序无所谓，str1的这个最短子串也可以包含多余的字符
返回这个最短包含子串</p></blockquote> <p>求一个str2的长度length</p> <p>扩一个长度为length的窗口,从str1开始走,如果不能配上str2的所有字符.求包含字符的,不是子串相等的,一个欠债问题,每个str2字符欠多少个,和总欠账多少个,窗口右扩,当str1被窗口多罩住一个,欠账就可能少一个,欠账count==0时候,说明,凑够了,记录一个范围.</p> <p>此时窗口l开始缩.只要欠账count依然等于0,继续收集答案.如果count&gt;0了,r右扩.直到越界,收集最短的答案即可.</p> <h4 id="_25-4-149-良好加油站问题"><a href="#_25-4-149-良好加油站问题" class="header-anchor">#</a> 25-4-149-良好加油站问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35078&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/gas-station/</p> <blockquote><p>给定两个数组,gas数组和dis数组,代表能源和到下一个站的距离,问从哪个站出发,能跑完一圈叫良好出发点,返回所有良好出发点.</p> <p>要求,空间复杂度O(1),时间复杂度O(N)</p></blockquote> <p>题目要的是一个结果数组,所以返回一个数组,不算额外空间.</p> <p>先用gas数组-dis数组-,原地修改gas数组,我们还能改回来,dis数组再＋这个数组就搞出来了</p> <p>这个gas数组,负数的,一定不是良好的出发点.因为他都到不了下一站,</p> <p>那好,正数的,我们从最后一个开始看,设置两个变量,rest我剩多少油,need我需要多少油能走到窗口最后</p> <p>他一点点右扩,扩一个,reset减掉距离,加上gas,如果走完一圈了,rest还&gt;0,说明是良好出发点,</p> <p>如果不行了,当前点记录,不是良好出发点,左扩,need= need➖油+距离,如果联通了,说明是良好出发点,否则,继续出发,如果联通了,都没有良好出发点,那不用找了,不会有了,</p> <p>带着大于等于0的油都走不下去,小于0的出发更不可能.</p> <h2 id="堆问题"><a href="#堆问题" class="header-anchor">#</a> 堆问题</h2> <h4 id="二维接雨水问题"><a href="#二维接雨水问题" class="header-anchor">#</a> 二维接雨水问题</h4> <p>https://www.bilibili.com/video/BV16o4y1c77G?p=181&amp;vd_source=aa2ca96f997833d2dcbb3cf9f4cd33ac</p> <blockquote><p>还是接雨水,只是他是一个二维数组,问这个二维数组方块内,能接到多少雨水.</p></blockquote> <p>思路是:这个问题要用到堆,首先找到最外面一圈的最低点,也就是薄弱点,把这一圈,全部放到小根堆中,堆顶,就是薄弱点,也就是说,里面的水,都会最先从这里溜走,然后处理这个薄弱点的上下左右,(咱们讨论的是4个方向的,斜向的不会溜走),放入堆中(node节点除了value,还有位置信息),找到下一个薄弱点,然后处理他边上的上下左右.</p> <ol><li><p>首先max=0;</p></li> <li><p>弹出一个最小值,能更新max吗?比他大就更新,</p></li> <li><p>接下来给他上下左右加进去堆里,加的时候,结算,如果小,那当前弹出点就是瓶颈,如果大,那结算值就是0.</p></li> <li><p>只要max不更新,就都是max的内湖区域</p></li></ol> <p><img src="/assets/img/d03.62479bac.jpg" alt=""></p> <h4 id="_10-3-65-最常使用的k个单词问题"><a href="#_10-3-65-最常使用的k个单词问题" class="header-anchor">#</a> 10-3-65 最常使用的k个单词问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34994&amp;courseVersionId=1348</p> <p>https://www.lintcode.com/problem/top-k-frequent-words-ii/</p> <blockquote><p>给定一组单词,实时的求返回的出现次数最多的k个单词,按从少到多返回.</p></blockquote> <p>这个题,要用到加强堆来解决.</p> <ul><li>一个大根堆,来实时的得到topK个单词,堆的大小等于k,多的我不要,不进堆.</li> <li>堆顶就是出现次数最多的,一个map,存单词出现的次数,</li> <li>一个map,加强堆的反向索引表</li> <li>一个treeMap.小优化,用来存从小到大的topK个数,直接返回这个就是结果.</li></ul> <h4 id="_18-5-115-两个有序数组间相加和topk问题"><a href="#_18-5-115-两个有序数组间相加和topk问题" class="header-anchor">#</a> 18-5-115-两个有序数组间相加和topk问题.</h4> <p>https://www.nowcoder.com/practice/7201cacf73e7495aa5f88b223bbbf6d1</p> <blockquote><p>两个有序数组,求相加和的topk,</p></blockquote> <p>topK,一般就是,堆.</p> <p>我先搞个堆,两个数组的一哥,组成节点node,都进来,按累加和排序.</p> <p>然后弹出一个,这是top1的数.</p> <p>我看看给第一个数组的上一个数或第二个数组的上一个数,分别组成node放到大根堆中,较大的弹出,此时,这个是top2,</p> <p>然后,他的弹出的继续,第一个数组的上一个数或者第二个数组的上一个数,两个数组放大大根堆,弹出,这是top3,,,按照这个规律,直到topK.</p> <p>node是啥啊,三个属性</p> <ul><li>第一个数组的index,</li> <li>第二个数组的index,</li> <li>累加和,就按照这个东西大根堆排序的.一个比较器搞定.</li></ul> <h4 id="_19-4-119-smallest-range-covering-elements-from-k-lists"><a href="#_19-4-119-smallest-range-covering-elements-from-k-lists" class="header-anchor">#</a> 19-4-119-smallest-range-covering-elements-from-k-lists/</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35048&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/</p> <blockquote><p>给定n个有序数组,问,每个数组取一个值,组成的新的数组,区间最小的问题.</p></blockquote> <p>这个题,原视频是用有序表做的,就是每个数组里取最小的,加到有序表里,然后一次弹出一个加进去这个数组的下一个判断是否有变小.</p> <p>我觉得用堆也能做(==新的见解:==为什么用有序表不用堆,是为了搞出来最大-最小值,算出这个范围的差距,而堆,只知道最小,不知道最大),做一个node,两个属性,一个是来源于第一个属性和第一个位置的数组,另一个是val.按val排小根堆.</p> <p>弹出一个,在这个数组中,继续下一个,加入堆,每次记录一个答案看看有没有变小,如果某个数组到头了,那就结束了,因为必须包含每个数组的某个元素.</p> <h4 id="_26-1-150-smallest-range-covering-elements-from-k-lists"><a href="#_26-1-150-smallest-range-covering-elements-from-k-lists" class="header-anchor">#</a> 26-1-150-smallest-range-covering-elements-from-k-lists/</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35079&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/</p> <blockquote><p>有三个有序数组，分别在三个数组中挑出3个数，x、y、z
返回 |x-y| + |y-z| + |z-x|最小是多少？</p></blockquote> <p>跟之前有个题很类似</p> <p>就是个堆,或者有序表,有序表呢就是能知道头多少,尾多少,能求差值,但是堆只能直到头多少,不知道尾多少.</p> <p>这个题,每个有序数组开头放到有序表里,然后最小的弹出,下一个放到里面,依次重复这个操作,直到,某个数组的先走完了,在这个过程中,增加一个收集答案的过程,将最小范围的记录下来.</p> <p>有序表会去重,重复的数值的会被过滤掉.重复值怎么处理???</p> <p>放在node里,先用val处理,如果val相当,用内存地址比,一定不能覆盖掉.这个需要注意.</p> <h2 id="字符串问题"><a href="#字符串问题" class="header-anchor">#</a> 字符串问题</h2> <h4 id="心得-4"><a href="#心得-4" class="header-anchor">#</a> 心得</h4> <ol><li><p>如果是字符串,需要哈希表记录的,我们可以用数组int[]替代,这个速度快非常多.ascii码256个可以替代所有字符.</p> <p>词频统计思想/字符转换思想,例如qwer,我们可以用0123替代,然后int[0]=3代表q字符出现3次.</p></li> <li><p>字符串转数组然后for循环的操作</p> <p><code>char[] c = str.toCharArray();</code></p></li> <li><p>注意如果0位置我能直接知道答案的,切记给从1开始的循环中,用到的map或者其他辅助数组要设置0位置的初始值.</p></li></ol> <h4 id="最长无重复子串问题"><a href="#最长无重复子串问题" class="header-anchor">#</a> 最长无重复子串问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34951&amp;courseVersionId=1348</p> <blockquote><p>求一个字符串中,最长无重复子串的长度</p></blockquote> <p>子串,那就是连续的,一看到子串,我们直接就想到开头结尾，然后取以i开头或者结尾，最大推多远，取max.</p> <p>然后i位置，能不能通过，前面的。。i-2，i-1，帮我，加速得到！</p> <p>所以这个题,就依赖2个东西,</p> <ol><li>我上一次出现的最右的位置，</li> <li>i-1最远推到哪里了，这两个，取min</li></ol> <p>两种情况分别用图表示</p> <p><img src="/assets/img/WechatIMG33.925fb8e5.jpg" alt=""></p> <p>注意,</p> <ol><li>我不需要一个完整的dp数组,我只需要一个变量,来滚动记录,因为i位置只需要i-1位置的.</li> <li>我记录前面的位置,可以用int[]加速,这个比HashMap快很多.ascii最多256个,所以,任何字符我都能记录下来.</li></ol> <h2 id="位运算题"><a href="#位运算题" class="header-anchor">#</a> 位运算题</h2> <h4 id="心得-5"><a href="#心得-5" class="header-anchor">#</a> 心得:</h4> <ol><li>妙用位图,一个int值就能代表32位.</li></ol> <h4 id="两个字符串摘要同类问题"><a href="#两个字符串摘要同类问题" class="header-anchor">#</a> 两个字符串摘要同类问题</h4> <blockquote><p>只由小写字母(a~z)组成的一批字符串都放在字符类型的数组String[] arr中</p> <p>如果其中某两个字符串所含有的字符种类完全一样就将两个字符串算作一类</p> <p>比如:baacbba和bac就算作一类返回arr中有多少类?</p></blockquote> <p>这个大家都能想到,排个序,去个重,然后哈希set一放,数量为1就是一类,否则就是2类.</p> <p>最优解:位运算,一个int值有32位,一共才26个字符,完全够了,我都不要排序,每个位置出现的1&quot;或&quot;到对应为止上,最后换算个int值,自动相当于排序了.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> key <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	key <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="数组问题-预处理数组"><a href="#数组问题-预处理数组" class="header-anchor">#</a> 数组问题(预处理数组)</h2> <h4 id="心得-6"><a href="#心得-6" class="header-anchor">#</a> 心得:</h4> <ol><li><p>求长方形,正方形的,</p> <p>遍历所有的长方形,时间复杂度,O(N^4),因为,在这个矩阵内部,我先点任意一个点,O(N^2),再点任意一个点,O(N^2),两个点组成的矩阵,就是O(N^4)</p> <p>那正方形呢,正方形是O(N^3),为什么,因为,在这个矩阵内部,我先点任意一个点,O(N^2),剩下的,就是0~N了,两个边一样长,所以O(N^3).</p></li> <li><p>当我一个操作,非常频繁的需要for循环了,我就要想办法,通过预加工数组,来省掉这个for,来做到O(1).例如判断是否全是1组成的正方形的</p></li> <li><p>根据数量猜解法,一般的,二维数组的时间复杂度比较高,所以优化是一方面,另一方面就是,根据条件给出的数量级猜测解法,例如矩阵最大100,那么我三次方,就是100w,10的7次方,不超过10的8次方,所以能过.但如果O(N^4),就过不了了</p></li> <li><p>如果给了多个数组,其中数据范围的数组极大,凑得值极大,看看有没有小的,如果某个数组小,直接分治.(动态规划二维表会爆!)</p></li> <li><p>看到子数组,子串,就是以某个位置结束,找往左扩到什么程度,最大.</p></li></ol> <h4 id="边框全是1的正方形面积问题"><a href="#边框全是1的正方形面积问题" class="header-anchor">#</a> 边框全是1的正方形面积问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34952&amp;courseVersionId=1348</p> <blockquote><p>给定一个只有0和1组成的二维数组
返回边框全是1的最大正方形面积</p> <ul><li><code>1 &lt;= grid.length &lt;= 100</code></li> <li><code>1 &lt;= grid[0].length &lt;= 100</code></li> <li><code>grid[i][j]</code> is <code>0</code> or <code>1</code></li></ul> <p>https://leetcode.com/problems/largest-1-bordered-square</p></blockquote> <p>思路:</p> <p>这个题没办法,我们要遍历每个位置,然后看看以这个顶点组成的正方形,组成的面积,收集答案,比较.所以至少是O(N^3).</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token class-name">N</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token class-name">M</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">//这一层,我的边界,取右侧或者下侧先撞墙的那个,,</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> border <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> border <span class="token operator">&lt;=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">N</span> <span class="token operator">-</span>i<span class="token punctuation">,</span><span class="token class-name">M</span><span class="token operator">-</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> border<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">//这里来个O(1)的,才能让他10^8以内能过</span>
<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre></div><p>我们看到这个最里面的for,判断是否可以组成边框为1的最大的面积,调用非常频繁,我们要通过预加工数组,来解决.</p> <p>假设我们任意一个点,右侧的1和下侧的1我都能知道有多少个,那么我又能快速的知道4个点的位置,我就能知道他是否是正方形.</p> <p>那么我们就可以预处理数据,</p> <p><img src="/Users/fengshouli/vuepressWorkspace/vuepress-start/docs/%E7%AE%97%E6%B3%95%E4%BD%93%E7%B3%BB/picture/1723127966361.jpg" alt=""></p> <p>我们发现,如果我们从左往右看,我们没办法知道右侧的较小的是否有正方形,起码O(1)不行,所以我们从大到小,挨个判断,先判断一个最小的初始值,然后让更大值覆盖,这样,假如从右向左,我们找到一个更大的,就覆盖下.</p> <h4 id="leetcode最接近sum子序列累加和问题"><a href="#leetcode最接近sum子序列累加和问题" class="header-anchor">#</a> leetcode最接近sum子序列累加和问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34954&amp;courseVersionId=1348</p> <blockquote><p>//本题测试链接:https://leetcode.com/problems/closest-subsequence-sum/</p> <p>给你一个数组,nums,nums.length 个数字,问返回一个子序列的累加和,最接近goal问题.</p> <p>// 本题数据量描述:
//1&lt;= nums.length &lt;=40</p> <p>//-10^7 &lt;= nums.[i]&lt;= 10^7</p> <p>// -10^9 &lt;= goal &lt;= 10^9</p> <p>//通过这个数据量描述可知，需要用到分治，因为数组长度不大</p> <p>// 而值很大，用动态规划的话，表会爆</p></blockquote> <p>40个长度,我直接左右分两半,左边20个,右边20个.</p> <p>左右,充分展开,都是2^20规模.104w+,百万级.肯定过.</p> <p>然后,左侧,每个都去右侧配对,看看能不能找到goal,(写代码时候,我就选择左右配对的方式,而不认为答案在单独的某一边,因为,左边可以选0个,这样也算是左右选,不会错过答案.)给右侧加入到有序表中,开启二分查找,左右结合,很快找到答案.</p> <p>有序表,100w个数,不是个事.</p> <h4 id="一个数组查询频繁-返回查询结果"><a href="#一个数组查询频繁-返回查询结果" class="header-anchor">#</a> 一个数组查询频繁,返回查询结果</h4> <blockquote><p>数组为{3,2,2,3,1}，查询为(0,3,2)</p> <p>意思是在数组里下标0~3这个范围上，有几个2?答案返回2.</p> <p>假设给你一个数组arr</p> <p>都给出来对这个数组的查询非常频繁，</p> <p>请返回所有查询的结果</p></blockquote> <p>首先,既然查询非常频繁,那肯定是要让你预处理数组了,</p> <p>第一种,找到每个数字,哪个下标有,有序数组中, 找到范围对应的位置,二分查找,logN级别.但是预处理的时候,占用的比较少.</p> <p>第二种,找到每个数组,0~i位置范围上的数量,例如0-1,0-2,0-3上有多少个,如果想找12-17上,就是0-17减去0-12的结果.O(1),但是,对预处理消耗较大.</p> <p>根据数据量猜解法,可以找到更合适的方法.</p> <h4 id="返回数组中-子数组最大累加和"><a href="#返回数组中-子数组最大累加和" class="header-anchor">#</a> 返回数组中,子数组最大累加和.</h4> <p>思路:</p> <p>先搞定0位置的答案,他肯定就是自己嘛,同时,确定了第一个答案.</p> <p>然后从1位置开始,他要不要向左扩,如果不扩,那答案就是它自己,如果要扩,那他肯定是加上左边的最好的嘛.就是上一个数的答案嘛.</p> <p>走一遍数组, 最后找到最大值,搞定.</p> <h4 id="返回一个二维数组中-子矩阵最大累加和"><a href="#返回一个二维数组中-子矩阵最大累加和" class="header-anchor">#</a> 返回一个二维数组中,子矩阵最大累加和.</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34956&amp;courseVersionId=1348</p> <blockquote><p>https://leetcode-cn.com/problems/max-submatrix-lcci/</p> <p>给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。</p> <p>返回一个数组 <code>[r1, c1, r2, c2]</code>，其中 <code>r1</code>, <code>c1</code> 分别代表子矩阵左上角的行号和列号，<code>r2</code>, <code>c2</code> 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p> <p>**注意：**本题相对书上原题稍作改动</p> <p><strong>示例：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入：
[
   [-1,0],
   [0,-1]
]
输出：[0,1,0,1]
解释：输入中标粗的元素即为输出所表示的矩阵
</code></pre></div><p><strong>说明：</strong></p> <ul><li><code>1 &lt;= matrix.length, matrix[0].length &lt;= 200</code></li></ul></blockquote> <p>这个题,用到了一个数组压缩技巧,我们上面说了一个一维数组,如何找到最大累加和,那么二维,我们把多行压缩到一起,然后来个一维数组的最大累加和求解,是不是就ok了.</p> <p>就是说,我先求第0行的,然后求第0-1行的,这个0-1行的,就是0行和1行压缩,每个对应位置的加起来,然后成了个一维的,然后求解,然后是0-2行,这个就是刚刚压缩后的,跟他压缩,,然后0-3行,也是0-2的压缩结果跟他继续压缩,所以,结果就是O(行^2*列^1),所以,看到没有,让小的那个当行,多的那个当做列,这样,整体最省.</p> <h4 id="返回一个数组中-选择的数字不能相邻的情况下最大子序列累加和"><a href="#返回一个数组中-选择的数字不能相邻的情况下最大子序列累加和" class="header-anchor">#</a> 返回一个数组中，选择的数字不能相邻的情况下最大子序列累加和</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34957&amp;courseVersionId=1348</p> <blockquote><p>返回一个数组中，选择的数字不能相邻的情况下最大子序列累加和</p></blockquote> <p>子序列,就不能想着以某个位置结束的时候了,只有子串,子数组这种连续的才行.</p> <p>那就从左往右尝试呗,我很容易,能得到,0-i,范围上,不相邻,这个子序列最大累加和多少. 怎么简单.</p> <ol><li><p>假设0-17范围,</p> <ol><li>p1 = 只要i位置的数</li> <li>p2 = 我就要17位置的数,好,那我就不能要16位置的,那就是0-15的那个结果,这个结果我有了,在dp里.</li> <li>p3 = 我不要17位置的数,注意,这也是0-17范围,我只是不要17位置这个数,那么,16我可要可不要,那不就是0-16范围的最好答案吗?</li></ol> <p>dp[i] = max(p1,max(p2,p3))</p></li></ol> <h4 id="非负数组-两个数-结果最大问题"><a href="#非负数组-两个数-结果最大问题" class="header-anchor">#</a> 非负数组,两个数&amp;结果最大问题.</h4> <blockquote><p>给定一个非负数的数组,长度一定大于1,想知道数组中哪两个数&amp;的结果最大.返回这个结果</p> <p>时间复杂度O(N),额外空间复杂度O(1)</p></blockquote> <p>思路:</p> <p>非负整数,那就看每个数的31位.</p> <p>求&amp;的结果,那肯定是高位&amp;完了还是1才好,</p> <p>那我就看31位,有几个数,是1的,</p> <p>如果小于2个,那不行,这一位挑不出来,只能看下一个稍小点的位,</p> <p>如果等于2个,那不用看了,这两个数,就是&amp;完了最大的.</p> <p>如果大于2个,好,那剩下的这位是0的全部淘汰只看这位是1的数.</p> <p>注意,我们可以搞个双指针,其中一个指针从头开始找1的位,后面的指针,指着淘汰区位置,</p> <h4 id="有序数组-每个数平方后不同结果数问题"><a href="#有序数组-每个数平方后不同结果数问题" class="header-anchor">#</a> 有序数组,每个数平方后不同结果数问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=52882&amp;courseVersionId=1348</p> <blockquote><p>给定一个有序数组arr，其中值可能为正、负、0返回arr中每个数都平方之后不同的结果有多少种?
给定一个数组arr，先递减然后递增,返回arr中有多少个绝对值不同的数字?</p></blockquote> <p>一类问题,双指针解决.</p> <p>两个指针,头尾,比绝对值,谁大,谁内滑,滑一次记录一个答案,如果相等,两个指针一起滑,如果滑的值一样,一滑到底,直到遇到不同的.</p> <p>当指针交错的时候,结束.拿到答案数.</p> <h4 id="_9-3-60最长递增子序列问题"><a href="#_9-3-60最长递增子序列问题" class="header-anchor">#</a> 9-3-60最长递增子序列问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=57231&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/longest-increasing-subsequence</p> <p>一看子序列,那就是可以不连续.</p> <p>dp[i],含义是,到i位置,最长可以多长.</p> <p>那我这个暴力解,时间复杂度O(N^2),但是,这个最优解,可以为O(N*logN)</p> <p>我们设置一个end辅助数组,和原数组一样长,分为有效区和垃圾区.有数据的就是有效区.</p> <p>有效区含义:end[i]代表遍历完i,没遍历i+1位置之前,代表目前,所有i+1长度的递增子序列中,最小结尾是end[i]的值.</p> <p>i=0.那就一个数,那最小值就是它自己被,再来个数,i=1如果小于等于,那他就给3干掉(或者说替换),如果大于3,那就直接排在3后面,当i=2时候,重复i=1的操作,end[]二分查找到的比他大的下标+1就是结果数,</p> <p>如果新来一个数,从辅助数组中二分查找比他大的,如果没有比他大的,现在辅助数组有效区的长度+1就是他最长递增子序列长度,如果没有,那他就把比他小于等于的那个位置的替换掉,他前面有多少个,那就是这个位置+1个数.这个做法,替换了原数组,前后的位置的都不影响.</p> <h4 id="_9-4-61俄罗斯套娃问题"><a href="#_9-4-61俄罗斯套娃问题" class="header-anchor">#</a> 9-4-61俄罗斯套娃问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=57232&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/russian-doll-envelopes/</p> <blockquote><p>输入一个两个维度的数组,长度和高度,约定大的能套在小的上面,</p></blockquote> <p>我们第一,按照长度排序,然后当长度相同的时候,按照高度高的在前面,高度低的在后面,这样然后再来一个最长递增子序列求解,答案,就是最多多少个套娃可以套在一起.</p> <p>为什么?</p> <p>我们想一下,当我们长度排序时候,后面的一定大于等于前面的,然后,如果我们看高度,我们收集递增子序列,前高后低,就是防止同样长度的捣乱.我们这样可以收集到同长度下,最小的那个,如果右边比我大,那他长度也一定比我大,他肯定能套住我,如果左边比我大,那他长度一定跟我相同,我们都套不住对方,我左边的也没啥用,淘汰.这样,我们得到递增子序列,就能得到最多套娃总数了.</p> <h4 id="_14-2-89-求arr中子数组累加和-k的-并且是最大的这个累加和的大小"><a href="#_14-2-89-求arr中子数组累加和-k的-并且是最大的这个累加和的大小" class="header-anchor">#</a> 14-2-89 求arr中子数组累加和 &lt;=K的,并且是最大的这个累加和的大小.</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35018&amp;courseVersionId=1348</p> <blockquote><p>请返回arr中，求子数组的累加和，是&lt;=K的并且是最大的
返回这个最大的累加和</p></blockquote> <p>看着子数组,实际上和字符串中的子串是一样的,都是以i位置结尾,然后往前看看,最远,能推到多远,那这个题就是,i位置,往左,最远能推多大,并且,&lt;=k</p> <p>那么怎么<strong>快速</strong>的求最远累加和是多少呢.累加和辅助数组,然后相减,</p> <p>例如,我k=300,现在i=83,累加和1000,那么实际上我就是要找累加和&gt;=1000-300 也就是大于等于700的累加和的位置,</p> <p>因为负数的存在,没有单调性,我们并不能让前一个数帮我快速得到答案.怎么办呢,</p> <p>我把前缀和,放在有序表里,我们超快就能拿到我们想要的&gt;=的某个值.</p> <h4 id="_25-2-2-三和问题"><a href="#_25-2-2-三和问题" class="header-anchor">#</a> 25-2-2-三和问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35074&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/3sum/</p> <blockquote><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p> <p>Notice that the solution set must not contain duplicate triplets.</p> <p>给个数组,给一个公式,问有哪些符合公式的答案,必须三个数相加,结果等于0</p> <p><strong>Example 1:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
</code></pre></div><p><strong>Example 2:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
</code></pre></div><p><strong>Example 3:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
</code></pre></div></blockquote> <p>要搞定这个问题,我们需要先搞定一个简单的问题,就是2和问题.2个数的和.当我拿到一个数5,我是不是,如果知道了哪两个数加一块是-5,是不是就得到答案了呢.</p> <p>所以,我们先给他排个序,然后定义一个方法,<code>List&lt;List&gt; res = f(num[],end,target)</code>含义是,0~end范围,能组成target的都返回,</p> <p>我们倒着遍历数组,假设N-1位置是5,那我找<code>f(num[],N-2,-(N-1))</code>,找到的list结果,都加上一个N-1位置,都是答案,为什么加到最后,因为这样效率高些, 因为如果插入到前面,所有元素还要拷贝.</p> <h4 id="_28-5-163-longest-common-prefix"><a href="#_28-5-163-longest-common-prefix" class="header-anchor">#</a> 28-5-163-longest-common-prefix/</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35092&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/longest-common-prefix/</p> <blockquote><p>编写一个函数来查找字符串数组中的最长公共前缀，如果不存在公共前缀，返回空字符串 &quot;&quot;。</p></blockquote> <p>公共的嘛,那我只要搞不到最长了,就缩,下一个来的时候,后面的更长的我都不看,只看到目前公共最长的.</p> <p>第一个和第二个比较,假设第一个15长度,第二个13长度,公共相同的10.</p> <p>那我第三个字符串来了,跟第二个比的时候,我只比到10,如果公共相同3,</p> <p>我第四个字符串来的时候,我只比到3....依次下去比到最后一个.</p> <h4 id="_29-3-175-merge-intervals"><a href="#_29-3-175-merge-intervals" class="header-anchor">#</a> 29-3-175-merge-intervals/</h4> <p>https://leetcode.com/problems/merge-intervals/</p> <blockquote><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi]
请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</p></blockquote> <p>按开始位置,拍个序,</p> <p>然后挨个遍历,记录当前开始位置的最大的结束位置,如果下一个新的开始位置开始的时候,在这个结束位置里时候,更新这个结束位置,他们合并成一个了,当再新来一个,他&gt;结束位置了,说明前一个区间找到了,我收集一个答案,</p> <p>有点像那个,最大重叠区间的,那个题是用堆做的,那个题呢,是把结束的都放到堆里,然后比下一个头小的都弹出,代表没有交集,然后收集堆里面的答案.就是当时遍历到的最大的重叠数.</p> <h4 id="_30-2-182-merge-sorted-array"><a href="#_30-2-182-merge-sorted-array" class="header-anchor">#</a> 30-2-182-merge-sorted-array/</h4> <p>这种题都写不对写不出来,一定挂</p> <p>https://leetcode.com/problems/merge-sorted-array/</p> <blockquote><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。
示例 1：
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
示例 2：
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]</p></blockquote> <p>两个指针,指到两个数组的结尾位置,谁大拷贝谁,相同的时候,先拷贝长的,为了让他更早的给空间释放出来.</p> <p>当短数组的while -- 跳出的时候,代表短数组拷贝完了,拷贝结束.</p> <h2 id="由小构建大的问题-分治"><a href="#由小构建大的问题-分治" class="header-anchor">#</a> 由小构建大的问题,分治</h2> <h4 id="心得-7"><a href="#心得-7" class="header-anchor">#</a> 心得:</h4> <ol><li>size个数达标,那么一半的数怎么达标,搞清楚规律是什么</li></ol> <h4 id="生成长度为size的达标数组问题"><a href="#生成长度为size的达标数组问题" class="header-anchor">#</a> 生成长度为size的达标数组问题.</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34958&amp;courseVersionId=1348</p> <blockquote><p>生成长度为size的达标数组，什么叫达标?</p> <p>达标:对于任意的i&lt;k&lt;j、满足 [i]+ [j] != [k]* 2</p> <p>给定一个正数size，返回长度为size的达标数组</p></blockquote> <p>思路:</p> <p>假如就三个数,a,b,c,那么达标就是a+c!=2b.</p> <p>那么一定符合2a,2b,2c -&gt; 2a+2c!=2*2b ,那么一定符合2a+1,2b+1,2c+1 <code>2a+1 + 2c+1 != 2*(2b+1)</code></p> <p>左边偶数,右边奇数,那么我让他左右边一起选,肯定也达标,因为,任何奇数加偶数,不可能等于某个数的二倍.</p> <p>所以假设size = 7,那么我搞个size=4的种子,然后,我搞个size=2的种子,然后,搞个为1的种子,这个为1的种子,就随便是多少都行.例如就选1.</p> <p>好,那么为2的种子就是左边✖️二,右边✖️二加一[2,3],然后求4的种子[4,6,5,7],然后求8这个数组[8,12,10,14,9,13,11,15],然后不要最后一个值不就行了.</p> <p>分治,左侧搞定单独,右侧搞定单独,然后想整合.</p> <h2 id="动态规划问题"><a href="#动态规划问题" class="header-anchor">#</a> 动态规划问题</h2> <h3 id="暴力递归"><a href="#暴力递归" class="header-anchor">#</a> 暴力递归</h3> <h4 id="汉诺塔最优状态问题"><a href="#汉诺塔最优状态问题" class="header-anchor">#</a> 汉诺塔最优状态问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35040&amp;courseVersionId=1348</p> <blockquote><p>给定一个数组arr，长度为N，arr中的值只有1，2，3三种
arr[i] == 1，代表汉诺塔问题中，从上往下第i个圆盘目前在左
arr[i] == 2，代表汉诺塔问题中，从上往下第i个圆盘目前在中
arr[i] == 3，代表汉诺塔问题中，从上往下第i个圆盘目前在右
那么arr整体就代表汉诺塔游戏过程中的一个状况
如果这个状况不是汉诺塔最优解运动过程中的状况，返回-1
如果这个状况是汉诺塔最优解运动过程中的状况，返回它是第几个状况</p></blockquote> <p>汉诺塔最优状态是什么:1-&gt;右,2-&gt;中,1-&gt;中,3-&gt;右,1-&gt;左,2-&gt;右,1-&gt;右.七步.</p> <p>问我在完美的走汉诺塔的时候,会不会有某一步,等于他给定的步骤,如果有返回是第多少步,否则返回-1</p> <p>首先明确下,汉诺塔最少步数,N层的话,(2^N) -1步,例如3层就是7步.</p> <p>我们给汉诺塔的三个柱子,定义为,from 1,other 2,to 3</p> <p>不管有多少层,N层,我们都是一个大的逻辑.三步走</p> <ol><li>N-2层,全部挪到other,</li> <li>N-1从from-&gt;to,</li> <li>N-2层,从other到to.</li></ol> <p>如果N-1很大,那就是无限次递归下去的.</p> <p>那我就真的走一遍呗,每走一步,记录下步骤数,然后看看:</p> <p>我们主函数,调用f(i,from,to,other),假设7层,就是arr[0~6],f,f(6,1,3,2),</p> <p>我们看下这个i,有没有任何可能,i,在other上,绝对不可能,根据上面的大逻辑,要么i上面的一坨还没挪走,那么要让i-1挪到other,要么就是上面一坨走了,那好我i直接到to,一步到位,</p> <p>basecase :i == -1.没有盘子了,返回0</p> <p>根据上面的分析:</p> <ul><li>arr[i] == other return -1;</li> <li>arr[i] == from 那说明,我还在起点呢,让我上面一坨去other,那我就调递归呗.f(i-1,from,other,to).</li> <li>最后的情况 arr[i] == to,那说明,第一大步走完了,那就是i-1层走完了,那继续呗.
<ul><li>p1 = (2^i)  - 1</li> <li>p2 = 1</li> <li>p3 = f(i -1 ,other,to ,from)</li> <li>当然这个是p3!=-1的情况下,return p1+p2+p3,否则直接返回-1.</li></ul></li></ul> <h3 id="动态规划-从左往右模型"><a href="#动态规划-从左往右模型" class="header-anchor">#</a> 动态规划-&gt;从左往右模型</h3> <h4 id="由去重数组arr-无限次使用拼出大字符串问题"><a href="#由去重数组arr-无限次使用拼出大字符串问题" class="header-anchor">#</a> 由去重数组arr,无限次使用拼出大字符串问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=52884&amp;courseVersionId=1348</p> <blockquote><p>假设所有字符都是小写字母</p> <p>大字符串是str</p> <p>arr是去重的单词表,每个单词都不是空字符串且可以使用任意次使用arr中的单词</p> <p>有多少种拼接str的方式.返回方法数</p></blockquote> <p>从左往右的动态规划,一个个试试,要与不要,能不能搞出来.O(N^2),真的是O(N^2)吗?不是,实际是O(N^3),因为我搞定当前位置的时候,要判断前缀串,在不在arr-&gt;set中,这又是O(N),总代价O(N^3).</p> <p>怎么优化!!!</p> <p>刚刚学过前缀树,我们先给arr放在前缀树中,当我们到一个i位置的时候,我们拿第一个字符,到前缀树中找,如果是isEnd=true的,那么1种方法,可以继续for,如果前两个字符,isEnd=true,又一种,继续三个字符,如果isEnd=false了,好,后面的都不用看了,没有了.字符总量是M,建树代价,O(M)+O(N^2),</p> <h4 id="_8-5-52矩阵正负零-蛇从左往右走-最大成长值问题"><a href="#_8-5-52矩阵正负零-蛇从左往右走-最大成长值问题" class="header-anchor">#</a> 8-5-52矩阵正负零,蛇从左往右走,最大成长值问题.</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=57885&amp;courseVersionId=1348</p> <blockquote><p>给定一个矩阵matrix，值有正、负、0
蛇可以空降到最左列的任何一个位置，初始增长值是0
蛇每一步可以选择右上、右、右下三个方向的任何一个前进
沿途的数字累加起来，作为增长值；但是蛇一旦增长值为负数，就会死去
蛇有一种能力，可以使用一次：把某个格子里的数变成相反数
蛇可以走到任何格子的时候停止
返回蛇能获得的最大增长值</p></blockquote> <p>思路:</p> <p>这个题,乍一看,很简单的一个从左往右,要不要就完事了,但是不对,不够,因为他可以用一次能力,</p> <p>我们需要返回2个信息,一个是用了能力的最大成长值,一个是不用能力的最大成长值,然后返回一个max,</p> <p>好,定义一个函数,info = f(arr[],i,j),代表,走到ij位置,必须停,用和没用能力的最大成长值返回,</p> <p>那basecase就是,0列,随机降落,</p> <p>否则,那就要依赖于前一列的值了,注意,我最多依赖i-1,i,i+1,如果我在0行,那不可能来自i-1行,如果在N-1行,不可能来自i行,</p> <p>三种可能性求最大值,然后,继续往下走,前提都是,之前的都能到,</p> <p>这三种可能性判断的时候,分2中,</p> <ol><li>我绝对不用能力,那就没什么好说了,最简单的情况.</li> <li>我要用能力,如果决定这次用,那我只能用之前no的结果,如果之前就用了能力了,那我这次就只能用no的结果了.</li></ol> <p>最后一个问题, 我这个动态规划,如何展示,我定义个三维<code>int[][][]</code>,但是,实际上,这是个二维的,因为,最后一个维度,我只代表,是用了还是没用能力.非0即1.</p> <h4 id="_11-5-75-字符串最少切几刀能全部变成回文串问题"><a href="#_11-5-75-字符串最少切几刀能全部变成回文串问题" class="header-anchor">#</a> 11-5-75-字符串最少切几刀能全部变成回文串问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35004&amp;courseVersionId=1348</p> <blockquote><p>问题一：一个字符串至少要切几刀能让切出来的子串都是回文串</p> <p>问题二：返回问题一的其中一种划分结果</p> <p>问题三：返回问题一的所有划分结果</p></blockquote> <p>问题一解法:</p> <p>一个从左往右的尝试,但是,这个是2个动态规划题.</p> <p>首先尝试,我从i开始,那么i...i+1,i...i+2,i...i+3,,,,,i...N-1 是不是回文串,是的话,后面最少分多少份</p> <p>分析一下这个复杂度,首先,每个i位置,都要来一遍i....i...N-1,这就是N^2了,但是真正的时间复杂度不止于此,因为,还有个判断是否回文串的过程,需要一个O(N),所以,综合下来,这个过程O(N^3),这个效率太低了,我们怎么弄,能让他降低复杂度呢.</p> <p>如果我们知道了,i...N-1任意范围上,是不是回文串,O(1),那是不是就能降低复杂度了呢.怎么得到呢.</p> <p>动态规划,一张二维表.</p> <p>同样的对角线,都是true,因为自己和自己肯定是回文,然后上面的对角线,两两对比,相同为true,不同为false,再往上,那就是,两头相等,且中间一坨也是true,那就是true,至此,我们可以得到任意范围上,是不是回文.</p> <p>最终上面的N^2的dp表,一维的,我们返回dp[0]即可,代表了0...N-1,最少分多少份</p> <h4 id="_13-1-84-谷歌面试题扩展版"><a href="#_13-1-84-谷歌面试题扩展版" class="header-anchor">#</a> 13-1-84 谷歌面试题扩展版</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35013&amp;courseVersionId=1348</p> <blockquote><p>谷歌面试题扩展版
面值为1~N的牌组成一组，
每次你从组里等概率的抽出1~N中的一张
下次抽会换一个新的组，有无限组
当累加和&lt;a时，你将一直抽牌
当累加和&gt;=a且&lt;b时，你将获胜
当累加和&gt;=b时，你将失败
返回获胜的概率，给定的参数为N，a，b</p></blockquote> <p>概率是什么?概率怎么求?</p> <p>求的答案的可能性数量/所有可能出现的情况数量 = 概率</p> <p>这个题:主要是为了省掉一个枚举过程:这个枚举过程是,当到了一个一个值的时候,如果他远没有到达最后的时候,需要每个牌点数都试试,然后算概率.这里就涉及了1~N的牌组枚举过程.</p> <p>我们分析下,假设,N=3,1000&lt;累加和&lt;1003时候获胜,问概率,那么我假设到5的时候,如何快速的获取?</p> <p>对于5来说,他依赖678,三个位置,因为N=3,如果说678的答案分别是abc,则f(5)=(a+b+c)/3,那你在看4是啥,4依赖的是567三个位置啊.</p> <p>已知f(5)=(a+b+c)/3,我们给f(5)的答案,用x替代,左右✖️个3,那么是不是 3x =  a+b+c,好那a+b 咋来啊,c是谁啊,c是f(8),那是不是说,3x-f(9)=a+b+c-f(8).那么f(4) = (x + a + b) /3也就等于 f(4)=(x+3x-f(8))/3,带进去实际就是f(4) = (f(5)+3 f(5) - f(8))/3</p> <p>抽象一下,f(i) = f(i+1) * f(i+1)*N -f(i+N+1),注意,这只是,普遍位置!!!当来到获胜边界位置时候,这个公式不适用!!因为他是basecase.</p> <ol><li>当到a的前一个适合,概率为(b-a)/N</li> <li>再往前推,当N罩不住了,开始漏出小尾巴的时候,也就是cur+1+N&lt;b了,需要上面公式的减去的内容,否则不需要减掉.</li></ol> <p>然后我们拿动态规划第一个格子的值,就是答案.</p> <h4 id="_16-1-97-返回arr子集能否累加出k问题"><a href="#_16-1-97-返回arr子集能否累加出k问题" class="header-anchor">#</a> 16-1-97 返回arr子集能否累加出k问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35026&amp;courseVersionId=1348</p> <blockquote><p>给定一个有正、有负、有0的数组arr，
给定一个整数k，
返回arr的子集是否能累加出k
1）正常怎么做？
2）如果arr中的数值很大，但是arr的长度不大,40个，怎么做？</p></blockquote> <p>思路:</p> <p>看到子集了,那就是每个字符,要或者不要,经典的从左往右模型可解.或者理解为,i位置的数,我用,或者不用,</p> <h5 id="暴力方法"><a href="#暴力方法" class="header-anchor">#</a> 暴力方法:</h5> <p>用呢,就是0~i-1来搞定K-arr[i-1],不用呢,就是0~i-1来搞定K,跟arr[i]就没任何关系.他俩取个||</p> <h5 id="优化一-dp"><a href="#优化一-dp" class="header-anchor">#</a> 优化一:dp</h5> <p>问题是,这个题说的是,有负数!!,其实也没啥,我们可以整个的将这个二维表负数区,推到正数区.</p> <p>我们过一遍数组,最小值min和最大值max都搞出来,这个就是我们二维表的范围,全部推到正数区</p> <p>初始值,<code>dp[0][0]=true</code>,我们不用0位置字符,搞出来0,<code>dp[0][arr[0]]</code>,用第0个数字,搞定数组第一个值.</p> <p>i,j一个双重for,搞<code>dp[i][j] = dp[i-1][j]不用i位置 |= dp[i-1][j-arr[i]]要用i位置</code></p> <p>最终,拿到<code>dp[N-1][K]</code>返回.</p> <h5 id="问题2-数值很大怎么办"><a href="#问题2-数值很大怎么办" class="header-anchor">#</a> 问题2,数值很大怎么办</h5> <p>数值很大,代表着,min~max数值范围区间非常大,那么我们的二维表可能就爆了.搞不定.但是,我们发现,arr个数不多,怎么办,</p> <p>==分治==:</p> <p>我们分成左右各20个,20个要或者不要,然后收集他们的结果,放到set中,,也就是2^20,100来万,这个成本完全可以接受啊,然后,我们分别算左边和右边,算完了以后,我们整合左边和右边,左边set取一个,右边set取一个,看看能不能搞出K.搞定</p> <h4 id="_15-1-93-股票问题"><a href="#_15-1-93-股票问题" class="header-anchor">#</a> 15-1-93-股票问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35023&amp;courseVersionId=1348</p> <blockquote><p>股票问题说的就是,给定一个数组,代表的是每个时刻,股价多少,问在各种不同的限制下,如何获得最大收益.</p></blockquote> <h5 id="股票问题1"><a href="#股票问题1" class="header-anchor">#</a> 股票问题1</h5> <p>https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</p> <blockquote><p>只能做一次交易,获得的利益最大是多少,如果不能获得,返回0.</p></blockquote> <p>这个题,就是看看每个位置卖出,能获得的利益多少,然后取max</p> <p>卖出的时候,当前买入的时刻越低越好,所以要设置一个min,来收集i位置前面的min,max(i-min,0).</p> <h5 id="股票问题2"><a href="#股票问题2" class="header-anchor">#</a> 股票问题2</h5> <p>https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</p> <blockquote><p>可以做无限次交易,获得的利益最多是多少.</p></blockquote> <p>我可以无限次交易,那我就每次低买高抛才是合适的,</p> <p>可是我不知道每次最高点,最低点是多少,但是呢,我能知道当前时刻,和下一次,是赔了还是赚了,那我就只要任何时刻,赚了前我就落袋为安不就行了吗?把一次持续上升的趋势,我都赚钱.如果是下行的,我就不买.这样过一遍数组,我就得到了最大收益.</p> <h5 id="股票问题3"><a href="#股票问题3" class="header-anchor">#</a> 股票问题3</h5> <p>https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/</p> <blockquote><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p> <p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong>  升级版是K笔交易。</p> <p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote> <p>这个题,是一个从左向右的尝试,二维表展开,是0~N数组位置能搞定最多0~K次交易,最多收入多少.</p> <p>basecase,0行,0列,都是0,不用管.</p> <p>分析普遍位置,假设.i=5,k=2,就是0~5,最多交易2次,问,最大收益多少.</p> <p>最大收益,和我的5位置,有关吗?</p> <ol><li>无关:那<code>p1=dp[4][2]</code>,反正跟我5位置没关系嘛.</li> <li>有关:那必须5位置参与了一次交易.那5位置可以是什么交易呢.
<ol><li>直接5买了就买,诶我就是玩,我就浪费一次交易机会.那<code>p2=dp[5][1]+arr[5]-arr[5]</code>前面的0~5完成1笔,然后5位置花了<code>arr[5]</code>,赚了<code>arr[5]</code></li> <li>5位置是卖出,前面的位置买入,那我可能43210位置是买入
<ul><li><code>p3=dp[4][1]+arr[5]-arr[4]</code>四五共同组成第二次交易,0~4位置组成第一次交易.赚了<code>arr[5]</code>,花了<code>arr[4]</code></li> <li><code>p4=dp[3][1]+arr[5]-arr[3]</code>三五共同组成第二次交易,0~3位置组成第一次交易.赚了<code>arr[5]</code>,花了<code>arr[3]</code></li> <li><code>p5=dp[2][1]+arr[5]-arr[2]</code>二五共同组成第二次交易,0~2位置组成第一次交易.赚了<code>arr[5]</code>,花了<code>arr[2]</code></li> <li><code>p6=dp[1][1]+arr[5]-arr[1]</code>一五共同组成第二次交易,0~1位置组成第一次交易.赚了<code>arr[5]</code>,花了<code>arr[1]</code></li> <li><code>p7=dp[0][1]+arr[5]-arr[0]</code>零五共同组成第二次交易,0~0位置组成第一次交易.赚了<code>arr[5]</code>,花了<code>arr[0]</code></li></ul></li> <li>所有的上面的可能性,取最大值,就是我<code>dp[5][2]</code>的值.</li></ol></li></ol> <p>看到枚举行为了,我们理应想到,通过临近位置,替代枚举行为.</p> <p>临近位置:<code>dp[5][3]</code>,<code>dp[6][2]</code>,</p> <p>展开<code>dp[6][2]</code>,我们发现,</p> <p>6位置可以要或者不要.</p> <ol><li>6位置无关,那<code>dp[6][2]的 p1=dp[5][2]</code></li> <li>6位置有关,那必须6位置参与了一次交易,
<ol><li>直接6位置买了就卖,<code>p2=dp[6][1]+arr[6]-arr[6]</code>.</li> <li>5买6卖,<code>p3=dp[5][1]+arr[6]-arr[5]</code></li> <li>4买6卖,<code>p4=dp[4][1]+arr[6]-arr[4]</code></li> <li>3买6卖,<code>p5=dp[3][1]+arr[6]-arr[3]</code></li> <li>2买6卖,<code>p6=dp[2][1]+arr[6]-arr[2]</code></li> <li>1买6卖,<code>p7=dp[1][1]+arr[6]-arr[1]</code></li> <li>0买6卖,<code>p8=dp[0][1]+arr[6]-arr[0]</code></li></ol></li></ol> <p>有替代的可能性吗???好像不行啊,但是,我们换个想法,把中间的一坨,+arr[]去掉,这样,就出现了完全一样的内容了.</p> <p>所有值加相同值求最大值,和最大值求完了再加这个值,是一样的!!.</p> <p>那么<code>dp[5][2]</code>给<code>dp[6][2]</code>提供了哪些帮助呢?</p> <p>我们看不同点,</p> <ol><li>一个ij位置,首先不参与的时候,一个可能是<code>dp[i-1][j]</code>,因为我i位置不参与嘛.</li> <li>然后,看我6-2比5-2,多了个到6的,是我i专属的,也就是<code>dp[i][j-1]-arr[i]</code>,对应上面的<code>p2=dp[6][1]+arr[6]-arr[6]</code>,</li> <li>最后就是重复的一坨,依赖上一次,最好的期望,去掉+arr[]的那个,的best值.也就是<code>p3~p8</code>这段是<code>dp[5][2]</code>搞过了的.提取出不加arr[]的部分就是,从上往下,每次都比较,然后留下best.</li></ol> <p>原题中的不能超过2笔,我们给k=2带进去,即可搞定.</p> <h5 id="股票问题4"><a href="#股票问题4" class="header-anchor">#</a> 股票问题4</h5> <p>https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china</p> <blockquote><p>这个题就是上题k=2的原题</p></blockquote> <h5 id="股票问题5"><a href="#股票问题5" class="header-anchor">#</a> 股票问题5</h5> <p>https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</p> <blockquote><p>存在cooldown,也就是冷却, 每次买完了,需要等1个时刻,才能再买入.问最大收益多少.无限次交易.</p></blockquote> <p>这个题和上面的3,4,区别在于,这是无限次,上面的是有k次限制,</p> <p>这样想,我在一个i位置,我必须卖出,那么就要求,我前面的范围中,我能得到的最好收益,在选择一个最好的买入点,再提前减去这个买入点的成本.我用一个buy数组代替他.</p> <p><code>buy[i]</code>,含义就是0~i买入最好收益减去一个良好买入位置,最好的情况,</p> <p>i位置,是否买入,如果这个i不买入,那就跟我没关系,那就是<code>buy[i-1]</code>和 sell[i-2]-arr[i]求max,因为有colldown,所以i-1位置不能操作.sell是,我卖出的获取的最好的收益,我们下面讨论.</p> <p><code>sell[i]</code>,要么我i位置不卖出,那就是sell[i-1]和buy[i-1] +arr[i]取max.</p> <p>basecase是:当0~1范围时,buy[1]=谁比较小,选谁,因为有colldown,无法完成一次交易再买入,而buy是综合良好买入,必须买了,所以选个小的买入.</p> <p>当0~1范围时,sell最大的值,就是第二个值减去第一个值,如果赚了,就交易,否则,不交易,sell[1] = max(0,arr[1]-arr[0])</p> <p>i从2开始,滚动下去,返回sell最后一个格子的值即可.</p> <p>后续可以空间压缩,用有限变量,替代数组.</p> <h5 id="股票问题6"><a href="#股票问题6" class="header-anchor">#</a> 股票问题6</h5> <p>https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</p> <blockquote><p>可以无限次交易,也没有colldown,但是每笔交易,有个fee的手续费.</p></blockquote> <p>这题跟上面的一样,甚至更简单了,都没有colldown,</p> <p>唯一的区别是,交易达成的时候,扣fee,但是,先扣费,和后扣费,一样不?固定金额的.</p> <p>所以还是,buy,sell,每个最好值bestbuy,bestSell往后推,实际上就是压缩数组.</p> <p>唯一的跟上面的题不一样的是,我buy的时候,要扣掉一个fee,先扣,这样,卖的时候,我就能直接加了.</p> <p>basecase,0位置算出来bestbuy,bestsell,</p> <p>如果i位置必须买,前面的良好卖➖当前买入价➖fee,fee应该也可以放在sell－</p> <p>如果i位置必须卖,前面的良好买(包含买入价和扣费了),bestbuy,直接怼上当前arr[i]</p> <p>返回最后的bestsell即可.</p> <h4 id="_17-5-107-返回str所有子序列有多少种不同字面值"><a href="#_17-5-107-返回str所有子序列有多少种不同字面值" class="header-anchor">#</a> 17-5-107-返回str所有子序列有多少种不同字面值</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35036&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/distinct-subsequences-ii/</p> <blockquote><p>给定一个字符串Str
返回Str的所有子序列中有多少不同的字面值</p></blockquote> <p>子序列问题,我可以选择i位置,要或者不要,但是我不能改变原数组的位置.</p> <p>这个题,你写一个数组,随便写,然后,列出来所有的结果集,你找一下规律看看.</p> <p>他主要想考的是,如果处理重复的问题.然后最后返回的是数量,不是所有内容,这就意味着,应该是可以通过公式,算出来的.</p> <p>我们先看下,</p> <p>0~0时,多少种,2种,空的和{空的+它自己}.</p> <p>0~1时候,多少,如果不同,是否与我有关?</p> <ul><li>无关=上面的全部拷贝过来,2种,</li> <li>有关=每种里面加个当前的i,</li> <li>两者相加,就是我的值</li></ul> <p>0~2的时候,多少,假设,开始重复了,那么,重复的,是谁??假设12112这个数组.</p> <ul><li>第一次,{},{1}</li> <li>第二次,无重复:与我无关的{},{1},与我有关的{2},{1,2},</li> <li>第三次,有重复:与我无关的{},=={1}==,{2},{1,2},,与我有关的{1},{1,1},{2,1},{1,2,1}</li> <li>第四次,有重复:与我无关的{},{2},{1,2},=={1}====,{1,1}==,=={2,1},{1,2,1}==,与我有关的{1},{2,1},{1,2,1},{1,1},{1,1,1},{2,1,1},{1,2,1,1}</li> <li>第五次,有重复:与我无关的{},=={2},{1,2}==,{1},{2,1},{1,2,1},{1,1},{1,1,1},{2,1,1},{1,2,1,1},与我有关的,{2},{2,2},{1,2,2},{1,2},{2,1,2},{1,2,1,2},{1,1,2},{1,1,1,2},{2,1,1,2},{1,2,1,1,2}</li></ul> <p>我发现,这个规律,每次当出现了重复值的时候,他出现的重复值是什么?是上次,我出现的时候,与我有关的那些个东西,也就是说如果,我弄个辅助数组,给我上次出现的,与我有关的答案,都记录下来,那么,是不是这次结果算完了,然后直接给那个辅助数组的值减掉就行了呢?这样应该就正确的.</p> <p>原视频中,讲的没有动态规划,这个动态规划是我自己根据学的技巧,子序列想到的背包,i位置要不要,与我是否有关等,然后想出来的,到时候可以放到对数器中一起试一下.</p> <h4 id="_18-4-114-最大路径和问题"><a href="#_18-4-114-最大路径和问题" class="header-anchor">#</a> 18-4-114-最大路径和问题</h4> <p>https://www.nowcoder.com/questionTerminal/8ecfe02124674e908b2aae65aad4efdf</p> <blockquote><p>这个是贪心的那节课讲的一个题,一个二维矩阵,从左上到右下,再回来,最大的收益多少</p> <p>去的时候,只能右或者下,回来时候,只能左或者上</p></blockquote> <p>问一下,这个玩意,跟我从左上到右下,来2次,有什么区别,不就是第二次到达同一个坑位的时候,果实只计一份吗??</p> <p>那就AB两个,小人,a,b,c,d四个坐标代表AB的位置,</p> <p>best = 0</p> <ul><li>best = A右的时候,
<ul><li>best = max(best,B右,)</li> <li>best = max(best,B下,)</li></ul></li> <li>A下的时候
<ul><li>B右</li> <li>B下</li></ul></li></ul> <p>注意判断下边界,能不能走下或者走右.</p> <p>就这四种情况,当arr[i],A走到某个点的时候,如果B走到了同一个点,他们一定是完全相同的步骤.不可能不同步骤.</p> <p>走完了以后, 算算当前能得到多少</p> <p>if(a==c),走到一个格子了.cur = 当前格子</p> <p>else 不同的格子,cur = 两个位置的格子相加.</p> <p>return cur+best;</p> <p>basecase是啥,走到最后一个位置了,返回dp右下角的格子的值.</p> <p>优化:根据之前体系学习班里面说的,可变参数能省则省,这里abcd是4个,就是4维动态规划.</p> <p>简化d,a+b=c+d,我只给abc,a+b-c就是d.这样就变成了3维动态规划.</p> <h4 id="_19-5-120-扑克牌达标数量问题"><a href="#_19-5-120-扑克牌达标数量问题" class="header-anchor">#</a> 19-5-120-扑克牌达标数量问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35049&amp;courseVersionId=1348</p> <blockquote><p>一张扑克有3个属性，每种属性有3种值（A、B、C）
比如&quot;AAA&quot;，第一个属性值A，第二个属性值A，第三个属性值A
比如&quot;BCA&quot;，第一个属性值B，第二个属性值C，第三个属性值A
给定一个字符串类型的数组cards[]，每一个字符串代表一张扑克
从中挑选三张扑克，一个属性达标的条件是：这个属性在三张扑克中全一样，或全不一样
挑选的三张扑克达标的要求是：每种属性都满足上面的条件
比如：&quot;ABC&quot;、&quot;CBC&quot;、&quot;BBC&quot;
第一张第一个属性为&quot;A&quot;、第二张第一个属性为&quot;C&quot;、第三张第一个属性为&quot;B&quot;，全不一样
第一张第二个属性为&quot;B&quot;、第二张第二个属性为&quot;B&quot;、第三张第二个属性为&quot;B&quot;，全一样
第一张第三个属性为&quot;C&quot;、第二张第三个属性为&quot;C&quot;、第三张第三个属性为&quot;C&quot;，全一样
每种属性都满足在三张扑克中全一样，或全不一样，所以这三张扑克达标
返回在cards[]中任意挑选三张扑克，达标的方法数</p></blockquote> <p>这个题,我如果每个排,3个3个组队,然后判断,那就是N^3,那肯定废了.</p> <p>我们发现,只有3个属性,ABC,那所有的牌,只可能有多少牌面啊.27中.3^3,我们给所有牌面做个词频表.</p> <p>AAA,AAB,AAC~~~~CCC 27种.</p> <p>然后我们从左到右,找找能不能成功呗,如果成功了,我们去词频表,直接取数量,相乘,就是这三种牌面能得到的数量.</p> <p>但是AAA,BBB,CCC,这三个和,BBB,CCC,AAA,组成的一样不.是不是完全一样,那==就不能算重复了啊.咋弄呢???==.</p> <p>我们只往后算,意思是我们给27种牌面分别定义为1~27,例如AAA,就是1, 我后续配对的只找比pre大的..这样可以防止重复.</p> <h4 id="_30-3-183-decode-ways"><a href="#_30-3-183-decode-ways" class="header-anchor">#</a> 30-3-183-decode-ways/</h4> <p>https://leetcode.com/problems/decode-ways/</p> <blockquote><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
'A' -&gt; 1
'B' -&gt; 2
...
'Z' -&gt; 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&quot;11106&quot; 可以映射为：
&quot;AAJF&quot; ，将消息分组为 (1 1 10 6)
&quot;KJF&quot; ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 &quot;06&quot; 不能映射为 &quot;F&quot; ，这是由于 &quot;6&quot; 和 &quot;06&quot; 在映射中并不等价。
给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
题目数据保证答案肯定是一个 32 位 的整数。</p></blockquote> <p>这个是体系学习班中学习过的题,这个题的重点是,不能让0独立面对翻译.所以,就是发现当前是0时候,说明之前的决定不正确,</p> <p>然后就从左往右尝试嘛,当前1个独立面对,当前加下一个一起面对,然后跳n+2.</p> <h4 id="_30-3-184-decode-ways-ii"><a href="#_30-3-184-decode-ways-ii" class="header-anchor">#</a> 30-3-184-decode-ways-ii/</h4> <p>https://leetcode.com/problems/decode-ways-ii/</p> <blockquote><p>一条包含字母 A-Z 的消息通过以下的方式进行了编码：
'A' -&gt; 1
'B' -&gt; 2
...
'Z' -&gt; 26
除了上述的条件以外，现在加密字符串可以包含字符 '<em>'了，字符'</em>'可以被当做1到9当中的任意一个数字。
给定一条包含数字和字符'<em>'的加密信息，请确定解码方法的总数。
同时，由于结果值可能会相当的大，所以你应当对109 + 7取模。（翻译者标注：此处取模主要是为了防止溢出）
示例 1 :
输入: &quot;</em>&quot;
输出: 9
解释: 加密的信息可以被解密为: &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;.
示例 2 :
输入: &quot;1*&quot;
输出: 9 + 9 = 18（翻译者标注：这里1<em>可以分解为1,</em> 或者当做1*来处理，所以结果是9+9=18）</p></blockquote> <p>这个是183题的加强版,他是在里面加入了*,这个可以替代1~9,注意不包含0.</p> <p>所以,主流程是这样的,</p> <p>basecase不变,还是,走到了最后为止了,就是返回1,代表这是一种方法.</p> <p>如果当前0当度面对当前转换,return0,剪枝.</p> <p>当前位置是不是<code>*</code>,分开讨论</p> <p>不是{</p> <p>​	p1= 单转,跳下一个</p> <p>​	p2=不越界超范围的情况下,不超26,可以联合转,跳+2位置.</p> <p>​	注意啊,p2是需要讨论下一个位置是不是*的啊,</p> <p>​	不是,{</p> <p>​		不超就是一种,</p> <p>​	}是{</p> <p>​		第一位是1或者2的情况下,*,2可以转化为123456六种,1可以转化为9中,,则<code>[i]==1?9:6*process(跳+2位置)</code></p> <p>​	}</p> <p>​	return p1+p2</p> <p>}是{</p> <p>​	那我得看看下一个是不是啊,</p> <p>​	不是{</p> <p>​		如果下一个是0123456,我可以是1,2,两种,如果是6789,我只能是1,</p> <p>​	}是{</p> <p>​		<code>**</code>这种情况,1拼个1~9 2拼个1到6共15种.</p> <p>​	}</p> <p>}</p> <p>所有情况列举完了.</p> <p>这个题,结果比较大, 结果需要取个摩.</p> <p>挂缓存,动态规划,都可以搞了.可以自己试试.</p> <h3 id="动态规划-样本对应模型"><a href="#动态规划-样本对应模型" class="header-anchor">#</a> 动态规划-&gt;样本对应模型</h3> <h4 id="心得-8"><a href="#心得-8" class="header-anchor">#</a> 心得:</h4> <ol><li>样本对应模型,就是根据结尾位置做可能性判断.!!</li> <li>给定两个东西,凑第三个东西的!!!例如str1 for i,str2 for  j,凑str3的,要么str[i+j-1]位置完全来自第一个,要么str[i+j-1]位置完全来自第二个,要么dp[i+j-1]等于str1的i-1字符,并且除了最后一个字符由str1搞定,前面的都可以搞定(<code>dp[i-1][j]</code>),要么dp[i+j-1]等于str2的j-1字符,并且除了最后一个字符由str1搞定,前面的都可以搞定(<code>dp[i][j-1]</code>)</li></ol> <h4 id="字符串交错组成问题"><a href="#字符串交错组成问题" class="header-anchor">#</a> 字符串交错组成问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34959&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/interleaving-string/description/</p> <blockquote><p>给定str1,str2,保证相对顺序不变,把两个字符串随机交错在一起,组成一个字符串,问,给定的str3,是否是str1和str2交错而成.</p></blockquote> <p>思路:这个题,用merge的思路解决不了,因为你不知道要消str1还是str2.消错了相对次序就乱了.</p> <p>这个题用动态规划,样本对应,</p> <p>首先边界,如果str1.length+str2.length !+ str3.length,那肯定不是交错组成的.</p> <p>一张ij二维表,第0行,j列,代表完全从str2取j个,能不能凑出<code>str3(0+j)个字符</code>,第0列,代表完全从str1取,能不能凑出str3(i+0)个.</p> <p>普遍位置的话,就是从str1取i个,从str2取j个,能不能凑出来str3(i+j)个,一张二维表,右下角的位置,就是答案.</p> <p><code>p1 = str3[i+j-1] == str1[i-1] &amp;&amp; dp[i-1][j]</code>,前面的代表,交错字符的最后个位置,可以来自str1,因为他们相等, 并且,交错字符前面那一坨是能搞定的.是true</p> <p><code>p2 = str3[i+j-1] == str2[j-1] &amp;&amp; dp[i][j-1]</code>,前面的代表,交错字符的最后个位置,可以来自str2,因为他们相等, 并且,交错字符前面那一坨是能搞定的.是true</p> <p><code>dp[i][j] = p1 || p2</code>, 搞定</p> <h4 id="编辑距离问题"><a href="#编辑距离问题" class="header-anchor">#</a> 编辑距离问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34964&amp;courseVersionId=1348 后半部分</p> <p>经典问题,年年都考</p> <blockquote><p>给定两个字符串,例如ab1c,abc,如果保留代价是0,删除代价是d,增加代价是a,替换代价是r,问右第一个搞到第二个字符,最小代价的编辑方式代价是多少.</p></blockquote> <p>思路:</p> <p>样本对应模型.</p> <p>很简单的一个题.二维表拉开.<code>dp[][]</code></p> <p>抛开0行0列的计算,剩下的普遍位置,就四种可能性</p> <ol><li>str1最后一个字符之前面一坨,搞定str2字符这么多代价,然后加一个删除代价.<code>dp[i-1][j] + d</code></li> <li>str1当前i个,搞定str2字符除了最后一个字符这么多代价,然后加一个str1增加一个j-1的代价.<code>dp[i][j-1] + a</code></li> <li>当str1的i-1位置字符==str2的j-1位置的字符,那么只需要一个之前的代价,<code>dp[i-1][j-1]</code></li> <li>当str1的i-1位置字符!=str2的j-1位置的字符,那么需要一个之前的代价+一个替换字符的代价,<code>dp[i-1][j-1]+r</code></li> <li>四种代价取最小即可.</li></ol> <p>时间复杂度O(M*N)</p> <h4 id="编辑距离变体-最少删除多少个字符-可以让第一个为第二个的子串"><a href="#编辑距离变体-最少删除多少个字符-可以让第一个为第二个的子串" class="header-anchor">#</a> 编辑距离变体-最少删除多少个字符,可以让第一个为第二个的子串.</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34966&amp;courseVersionId=1348</p> <blockquote><p>给定两个字符串,问最少str2删除多个个字符串,能使他变成str1的子串.</p> <p>例如,s1 = &quot;abcde&quot;,s2 = &quot;axbc&quot; 返回1</p></blockquote> <ol><li><p>第一种暴力解法:</p> <p>如果str1 = M ,str2 = N</p> <p>我列举str2的所有子序列组合,那就是2^N,这么多个,每个都完全展开嘛,要或不要,然后,按照从长到短,排个序,挨个做kmp,先看看长的是不是能作为子串,然后找到后,长度减一下,就能得到删除几个字符了,时间复杂度O(2^N * M) 如果N很小,用这个</p></li> <li><p>我们上面刚刚看过编辑距离问题,:</p> <p>如果.我们给str1,每一个子串都列出来,然后,str2编辑成每一个子串,求一个最小代价.</p> <p>时间复杂度.所有子串<em>每个编辑距离 O(M^2 * N</em>M) 也就是 O(M^3 * N) 如果N比较大,就选这个</p> <p>拉出来一张二维表,只能删除,所以右上部分没有用.只能多变少</p></li> <li><p>2方法的优化.视频40分钟后开始.</p> <p>我们发现,是每一个子串,都画一张表,所以是M^2 ✖️ 编辑距离.</p> <p>但是我们发现,0-0我们填完了,画0-1这张表的时候,0-0我们又重新算了一遍,这不就是0-0扩出来一列吗???</p> <p>0-2的时候,不就是0-1这个表又扩了一列吗?</p> <p>那么现在复杂度如何变化了呢.假设一共5列,N=5,0-0~0-5搞的时候,实际就走了个5遍,1-1~1-5呢,4遍,然后2-2,3遍...这就是个M^2</p> <p>竖着每列走个N.复杂度,降为O(M^2 * N),复杂度降了一阶.</p></li></ol> <h4 id="给定一个字符串str-问从某个点出发-能否走出某个字符串问题"><a href="#给定一个字符串str-问从某个点出发-能否走出某个字符串问题" class="header-anchor">#</a> 给定一个字符串str,问从某个点出发,能否走出某个字符串问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=52254&amp;courseVersionId=1348</p> <blockquote><p>给定一个char[][] matrix，也就是char类型的二维数组，再给定一个字符串word，
可以从任何一个某个位置出发，可以走上下左右，能不能找到word？
char[][] m = {  { 'a', 'b', 'z' },
{ 'c', 'd', 'o' },
{ 'f', 'e', 'o' },<br>
设定1：可以走重复路的情况下，返回能不能找到
比如，word = &quot;zoooz&quot;，是可以找到的，z -&gt; o -&gt; o -&gt; o -&gt; z，因为允许走一条路径中已经走过的字符
设定2：不可以走重复路的情况下，返回能不能找到
比如，word = &quot;zoooz&quot;，是不可以找到的，因为允许走一条路径中已经走过的字符不能重复走</p></blockquote> <p>一个样本对应模型,</p> <p>我从f(i,j,k),代表从ij出发,能不能把string开头走出来前k个.</p> <p>从任何位置都能触发,所以我先来个N^2的遍历,代表任何位置出发,</p> <p>basecase,1.我k走到头了,那么能搞定,2.ij越界了,那肯定不能,字符不相等,那肯定也不能了,</p> <p>否则,那就继续上下左右四个方向调用呗.</p> <p>很简单的一个样本对应.</p> <p>第二问,如果不能走回头路了,那怎么办呢,我走过的路,给他置成0,然后,再往下调用,这样子过程走回来的时候,发现我是0,走不下去,但是记住了,如果是return回来的,要恢复现场,</p> <p>多问一句,这个第二种方法,能改动态规划吗?</p> <p>不能!!为什么,因为他改变了原数组,arr,一个二维的数组是变量,改不动.!!就像那个开关灯,环形开灯的问题,那个是加的变量来记住,前后位置灯的状态,而没有在原数组中改,否则就废了,改不动了.</p> <h4 id="_13-3-86-扰乱字符串-玄变字符串问题"><a href="#_13-3-86-扰乱字符串-玄变字符串问题" class="header-anchor">#</a> 13-3-86 扰乱字符串,玄变字符串问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35015&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/scramble-string/</p> <blockquote><p>一个字符串s1,从任意字符位置可以劈2半,然后,左右子树上分,最后呢,左右子树的内容可以互换,然后再拼到一起,得到一个新字符串s2,称之为s2为s1的玄变串.</p> <p>给定一个字符串s1和一个字符串s2,问,是否互为玄变串.</p></blockquote> <p>这个看到了2个字符串,是否互为 这几个字样,我们应该想到,样本对应模型!!!!!!!</p> <p>两个字符串对着比较,这个题,有个潜台词,分开的两段,可以互换位置,例如ab分开后,a,b 可以互换为b,a.</p> <p>那其实就是说2种互为玄变串的成立条件.假设某位置,0~N-1位置上任意选择位置一刀下去,然后</p> <ol><li>都没旋转,或者都旋转了,相对位置的内容应该一样.也就是左对左,右对右.</li> <li>其中一个旋转了,另一个没懂,那就是左对右,右对左</li></ol> <p>base case是什么,(左相等左 &amp;&amp; 右相等右) || (左相等右 &amp;&amp; 右相等左) 一直往下分,L==R了,只有一个字符了,相等就是,不等就不是,</p> <p>这个递归写出来后,我们发现是个4个可变参数的,L1,R1,L2,R2,这个太复杂了,我试了下,可以省掉一个参数,L1,L2,N,N代表共同长度,三个参数,改动态规划,三维搞定,N^3的复杂度,</p> <h4 id="_12-5-82-正则表达式匹配问题"><a href="#_12-5-82-正则表达式匹配问题" class="header-anchor">#</a> 12-5-82-正则表达式匹配问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35011&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/regular-expression-matching/</p> <blockquote><p>给定一个字符串str1,并且他一定不包含.或者*字符.</p> <p>再给定一个字符串exp,他可能含有.或者*,是个正则表达式.</p> <p>规则:.代表一个字符,可以变成任意的字符,*必须搭配前面一个使用,意思是,可以变成0~任意多个相同的前一个字符,</p> <p>所以.*可以匹配任意字符.</p> <p>问,exp,能否变成str1.</p></blockquote> <p>两个字符串,能不能凑出来,这是一个很明显的样本对应模型,也叫行列模型.</p> <p>核心思想就是,str1的某一段,是否能被exp的某一段,凑出来.</p> <p>那么怎么凑呢,我们以exp的i位置的下一个位置,是否为<code>*</code>来区分.</p> <ol><li>basecase是:exp到头了,str1也到头了,都没有字符了,好的,凑出来了,</li> <li>普遍位置:exp下一个位置不是* || 下一个位置到exp头了
<ol><li>那么非常简单了,那就是必须得能对上,相等,或者能变成,都算凑得出来str[i] == exp[j] || &quot;.&quot;== exp[j] 并且,后面的一坨,也能搞定,就是说str[i+1....],exp[j+1....]也能搞定</li></ol></li> <li>下一个位置是*了,这种情况比较复杂
<ol><li>我可能让<code>*</code>变成0个字符,那就是说,我str[i]和exp[j]凑出来了,例如,aaaab,和a<code>*</code>b,那我直接跳过第一个,让str[i+1]对位exp[j]试试,代表着,我让<code>a*</code>变成了一个a,抵消了str1的第一个a,如果我让str[i+2]和exp[j]对位呢,那就是让<code>a*</code>变成了两个a,抵消了str1的前两个a.==注意,这,其实是一个枚举行为,我们应该想办法给他搞掉,但是现在不考虑==</li> <li>当跳出上面的while的时候,那说明,当前str[i]位置,跟我的exp[j]位置,凑不出来了,例如<code>aaaab</code>,<code>a*b</code>,上面的b凑下面的a,凑不出来了,好,那么调用一次str[i]对比exp[j+2],跳过下面的<code>a*</code>,往后位置接着对比.</li></ol></li></ol> <h5 id="优化1"><a href="#优化1" class="header-anchor">#</a> 优化1:</h5> <p>挂个dp,直接傻缓存法</p> <p>我们弄一个<code>dp[][]</code>数组,0代表没走过,-1代表false,1代表true,带着这个缓存走,这已经足够优秀了,笔试,基本都能过,但是,他们有省略掉上面的枚举行为.</p> <h5 id="优化2"><a href="#优化2" class="header-anchor">#</a> 优化2:</h5> <p>所谓的枚举行为优化,基本就是找一个我上下左右的位置,来替代掉枚举行为,这个题也是一样,我看看从枚举行为的前一个str字符,后面的路,我都要走一遍,为什么不直接用后面的给我要走的替换掉呢.str[i],exp[j+2] || str[i+1],exp[j],这样,我们就用临近位置替换掉了枚举行为.</p> <h4 id="_14-3-105"><a href="#_14-3-105" class="header-anchor">#</a> 14-3-105</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35034&amp;courseVersionId=1348</p> <blockquote><p>给定两个字符串S和T
返回S的所有子序列中
有多少个子序列的字面值等于T</p></blockquote> <p>看到两个字符串了首先就得想到,样本对应模型.</p> <p>二维表,<code>dp[i][j]</code>,含义就是,字符串S的0~i范围,是否能搞定字符串T的从0~j范围.</p> <p>basecase是啥,?</p> <p><code>dp[0][0] = s[0] == t[0][0] ? 1 : 0</code>,就一个字符,相等就是1,不等就是0.</p> <p>第一列,我i都比j少,那肯定搞不出来.</p> <p>第一行,j不变,我i一个个字符变多,我只要当前位置等于j了,就多一个方法,否则直接拷贝前面的格子的.</p> <p>普遍位置依赖.</p> <p>i对应j,要么我跟我i没关系,那么<code>p1 = dp[i-1][j]</code>,要么跟我一定有关系,前提条件是,咱俩ij相等.<code>p2 = dp[i-1][j-1]</code>,</p> <p><code>dp[i][j]=p1+p2</code></p> <p>最后,返回右下角的格子即可.</p> <h3 id="动态规划-范围尝试模型"><a href="#动态规划-范围尝试模型" class="header-anchor">#</a> 动态规划-&gt;范围尝试模型</h3> <h4 id="_11-1-71-字符串至少添加多少个字符可以变成回文串问题"><a href="#_11-1-71-字符串至少添加多少个字符可以变成回文串问题" class="header-anchor">#</a> 11-1-71-字符串至少添加多少个字符可以变成回文串问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35000&amp;courseVersionId=1348</p> <blockquote><p>问题一：一个字符串至少需要添加多少个字符能整体变成回文串</p> <p>问题二：返回问题一的其中一种添加结果</p> <p>问题三：返回问题一的所有添加结果</p></blockquote> <p>这是个范围尝试题.</p> <ol><li>我们先试试每个字符单个的时候,这个范围,这就是对角线</li> <li>我们在尝试下2个字符的时候,这就是中间对角线上面的一条.这个过程可以简单的过程就获取到.</li> <li>然后我们分析可能性,
<ol><li>假设中间一坨,都能搞定,最后一个复制到第一个.</li> <li>假设中间一坨,都能搞定,第一个字符复制到最后一个.</li> <li>当收尾相等时候才存在,去除收尾,中间一坨自己搞定.</li></ol></li> <li>位置分析,当不存在3的时候,依赖下侧,左侧,当存在3的时候,依赖左下角.</li> <li>取min.</li></ol> <p><img src="/assets/img/WechatIMG34.1848317b.jpg" alt=""></p> <h2 id="树-二叉树"><a href="#树-二叉树" class="header-anchor">#</a> 树-二叉树</h2> <h4 id="心得-9"><a href="#心得-9" class="header-anchor">#</a> 心得:</h4> <ol><li></li></ol> <h4 id="给定一个bst-二叉树的先序遍历数组-请构建一棵树并返回头节点"><a href="#给定一个bst-二叉树的先序遍历数组-请构建一棵树并返回头节点" class="header-anchor">#</a> 给定一个BST,二叉树的先序遍历数组,请构建一棵树并返回头节点.</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34962&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/</p> <p>思路:</p> <ol><li>先序遍历,那就是头左右,</li> <li>bst,那么就是说,从第1位置开始数,直到遇到第一个比我大的数的时候,那就是我右孩子的开始.</li> <li>递归下去,我们把0位置构建为整个头节点,一会要返回的,1位置想象为L,R为第一个比我大的位置,那么L位置就是我的左子,R+1位置就是我的右子,我的主函数调process(arr[],L,R),他就能返回整棵树的头节点,它里面的子树,再继续找到属于他的LR,返回后,挂在我的头节点,继续下去.直到遍历完成.</li> <li>注意处理L,R边界.L&gt;R return null;例如没有左树的情况.</li> <li>这里面,每次process,需要遍历数组,找到第一个比头节点大的那个数字,这个阶段,很耗资源,离我最近的比我大的,是什么!!!单调栈!!,我们先走一遍数组,用单调栈,得到每个元素比我大的在哪.然后我们就可以用process(arr[],L,R,nearBig[])了,直接拿到谁是比我大的.</li></ol> <h4 id="一个节点-有多少相同的左右结构的子树问题"><a href="#一个节点-有多少相同的左右结构的子树问题" class="header-anchor">#</a> 一个节点,有多少相同的左右结构的子树问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34964&amp;courseVersionId=1348</p> <blockquote><p>节点x,如果左树结构和右树一样,算一个相同子树,给定一颗二叉树的头节点返回head整颗树上有多少颗相同子树(下)</p></blockquote> <p>思路:</p> <ol><li>首先,一个经典的递归过程,==每一个节点==跟我的左孩子,右孩子要信息,然后我汇总下.</li> <li>我定义两个方法,一个g(TreeNode TreeNode)方法,传入一个节点,返回相同子树个数,一个f(TreeNode t1,TreeNode t2),返回子树是否相等,那么我就调g(x.left)+g(x.right)+f(x.left+x.right)?1:0,就可以得到答案.</li> <li>判断是否左右是否完全相等.我们需要几个信息,左边的加上右边的</li></ol> <p>我们估算一下上面的时间复杂度,当我每个元素都是一样的,也就是不会提前Break或者return的时候,是最差的,g分左右,且验左右树,都得跑一遍,傻乎乎的O(N),那就是<code>T(N) = 2T(N/2)+O(N)</code> 这个不就是归并排序的复杂度吗?根据master公式,这就是O(N*logN)的复杂度.</p> <p>如果这个傻乎乎的跑一遍,验证子树是否相等的过程,能够省掉,变成O(1)的,那是不是就太爽了,整个过程,O(N)复杂度拿下.</p> <ol><li>我们看任意一个节点,如果他的左右子树,序列化成一个字符串,且有限长度,是不是这个比较过程是O(1)的.</li> <li>我们让一个子树序列化,很容易,但是,我们怎么能变成有限长度呢,头左右一直加在一起,很快就超长了.</li> <li>哈希!!根据哈希的特性,相同的输入,返回有限的输出,且输入相同,输出必定相同.</li> <li>我们将null用一个东西替代.然后将每一个子树序列化,那么我们这个事就能玩下去了,每个子树序列化结果,哈希后,交给父级树,</li> <li>哈希方法的时间复杂度,需要考虑吗?好问题!!因为用到了外届方法,这个哈希方法,他是跟输入有关的,我们的输入是固定长度的,所有,就是O(1).</li> <li>哈希碰撞怎么办,概率太低,5000年都遇不上,忽略不计.</li></ol> <h4 id="相机最小覆盖问题"><a href="#相机最小覆盖问题" class="header-anchor">#</a> 相机最小覆盖问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=52876&amp;courseVersionId=1348</p> <p>https://leetcode.cn/problems/binary-tree-cameras/description/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china</p> <blockquote><p>给定一个二叉树，我们在树的节点上安装摄像头。</p> <p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p> <p>计算监控树的所有节点所需的最小摄像头数量。</p> <p><strong>示例 1：</strong></p> <p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" alt="img"></p> <div class="language- extra-class"><pre class="language-text"><code>输入：[0,0,null,0,0]
输出：1
解释：如图所示，一台摄像头足以监控所有节点。
</code></pre></div></blockquote> <p>二叉树递归套路暴打一切!!</p> <p>好的,来分析吧.要信息吧.</p> <p>首先我所有返回的信息都保证一个前提,那就是返回的时候,他的子都已经确保被覆盖了,它自己无所谓,因为他还能被父的相机罩住,但是孙子级的,再也没有补救机会了.!!</p> <p>要信息吧.左树需要几个相机,右树需要几个相机,左树什么状态,右树什么状态,状态:没被覆盖,覆盖了有相机,覆盖了无相机,</p> <p>我把头节点调用这个process方法,他给我返回信息,每个头节点,去左右要信息,如果任何一个,没被覆盖,我,必须放一个,+1,如果左右任何一个有,那我就可以没有,直接返回,相机数不用+1,如果左右都被覆盖了,也都没有相机,那么也不用+1,只需状态改为没被覆盖状态,因为两个子都没有相机.</p> <p>到顶后,就得到了所有相机数.</p> <h4 id="_14-3-90-求一个完全二叉树的节点数量-要求-时间复杂度-不超过o-节点个数"><a href="#_14-3-90-求一个完全二叉树的节点数量-要求-时间复杂度-不超过o-节点个数" class="header-anchor">#</a> 14-3-90-求一个完全二叉树的节点数量,要求,时间复杂度,不超过O(节点个数)</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35019&amp;courseVersionId=1348</p> <blockquote><p>给定一个棵完全二叉树，
返回这棵树的节点个数，
要求时间复杂度小于O(树的节点数)</p></blockquote> <p>可以做到LogN</p> <p>完全二叉树,就算不满,也一定是从左到右变满的过程.</p> <p>利用这个特性,我们要知道,左右到底满不满,这就能快速的求出,一半的数量.我们首先,一路向左,直到null,看看树的高度.h</p> <ol><li>如果右树一路向左,h1和h一样,说明,左树肯定满了,那么整个左侧,2^(h-level),也就是1&lt;&lt;(h-level).这里的2^(h-level),例如h=3,level=1时,一侧满了,2^2=4,是算上了单边整个子树和头节点的!</li> <li>否则就是右树的高度,比h小1个,那说明,最底下那层还没越过中线,左侧都不满,那右侧肯定是满的,那右侧就有2^(h-level-1),也就是1&lt;&lt;(h-level-1).</li> <li>不管上述的1,2,哪侧不满,我们都能快速的算出另外一侧,然后针对不满的一侧,我们可以继续这个方法,bs(node.right/left,level+1,h);</li></ol> <p>basecase是什么,就是不管哪一侧,一层层往下,直到,level == h return 1;最低下一层了,直接返回,1个,</p> <h4 id="_14-5-92-最大子拓扑结构的节点数"><a href="#_14-5-92-最大子拓扑结构的节点数" class="header-anchor">#</a> 14-5-92 最大子拓扑结构的节点数</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35021&amp;courseVersionId=1348</p> <blockquote><p>从二叉树的某个节点x开始，往下子节点都要的，叫子树；
在二叉树上只要能连起来的任何结构，叫子拓扑结构；
返回二叉树上满足搜索二叉树性质的、最大子拓扑结构的节点数</p></blockquote> <p>这个题,引入了一个重要的概念:==贡献记录==</p> <p>当某个左右子节点的信息,对当前头节点的负责的时候,我们如何将这些信息,快速的改造到,让他们继续向上的头节点负责.</p> <p>对于二叉搜索子树来说,</p> <p>所有的左树,都比我小,右边的都比我大.</p> <p>那么对于他的头节点h来说,他的左树,一定全部比h小,可以直接使用.直接改为对h负责.</p> <p>但是对于右树来说,他不一定全部比新的头更小,怎么筛选,右树的头节点叫right,right如果符合,那right的左的贡献记录,一定都可用,然后right的右孩子,是否比h大,?如果大,就结束了,如果小,他变成right,看看他的左,如果小,全部可用,再看右,循环下去.</p> <h4 id="_20-1-121-能否不重建树的情况下-给定先序-中序-得到后序"><a href="#_20-1-121-能否不重建树的情况下-给定先序-中序-得到后序" class="header-anchor">#</a> 20-1-121-能否不重建树的情况下,给定先序,中序,得到后序.</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35050&amp;courseVersionId=1348</p> <blockquote><p>如果只给定一个二叉树前序遍历数组pre和中序遍历数组in，
能否不重建树，而直接生成这个二叉树的后序数组并返回
已知二叉树中没有重复值</p></blockquote> <p>知识回顾:</p> <p>先序:头左右</p> <p>中序:左头右</p> <p>后序:左右头</p> <p>二叉树递归套路,暴打一切.</p> <p>先序的头,在后续的哪里,最后一个位置是吧.是不是直接确定了一个了,哪段是左树呢??中序,在这里,找到头,L~头-1位置是做,头+1~R位置是右,对于先序来说,这个中序的L~头-1位置,这个长度,从先序里取这么长,就是一个新的先序,这两段加一块,是不是和一颗新的树一样呢?</p> <p>唯一的就是位置怎么用LR替代,怎么抽象化,</p> <p>画几个实际的例子,比划比划就出来了.</p> <p>注意边界条件.</p> <p>中序数组中,X可能在开头或者结尾,这样的时候,X左边或者右边没有数,也就是中序推先序的时候,推了个错误的位置,L1&gt;R1,这种情况,直接return.</p> <h4 id="_30-5-185-判断是否二叉搜索树"><a href="#_30-5-185-判断是否二叉搜索树" class="header-anchor">#</a> 30-5-185-判断是否二叉搜索树</h4> <p>https://leetcode.com/problems/validate-binary-search-tree/</p> <blockquote><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p></blockquote> <p>二叉树递归套路暴打一切,</p> <p>用二叉树递归套路生成一个中序数组,判断这个中序的是否都是从小到大的,如果是,那就是搜索树.</p> <h4 id="_20-6-186-判断一棵树是不是镜面树"><a href="#_20-6-186-判断一棵树是不是镜面树" class="header-anchor">#</a> 20-6-186-判断一棵树是不是镜面树</h4> <p>https://leetcode.com/problems/symmetric-tree/</p> <blockquote><p>给定一个二叉树，检查它是否是镜像对称的。</p></blockquote> <p>二叉树递归套路暴打一切,</p> <p>我跟我的孩子要信息,对于任意子树一视同仁.</p> <p>basecase都是null,返回true</p> <p>左孩子是不是镜面树,右孩子是不是镜面树,左孩子等于右孩子吗?递归一遍,主函数调用head,head,跟调用head.left,head.right一样的.</p> <h4 id="_20-6-187-binary-tree-zigzag-level-order-traversal"><a href="#_20-6-187-binary-tree-zigzag-level-order-traversal" class="header-anchor">#</a> 20-6-187-binary-tree-zigzag-level-order-traversal/</h4> <p>https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/</p> <blockquote><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p></blockquote> <p>-zigzag就是先左到右,然后再右到左,在左到右....这样遍历的方法.</p> <p>树宽度优先遍历,队列嘛.</p> <p>我们优雅的宽度优先遍历,是用一个变量,记录当前行的size,</p> <p>我们先把头节点放进度,记录size,然后遍历size个,弹出时候,给他的孩子挨个放进去,size到0时候,重新计算size,开始遍历,弹出一个,加载孩子进去,这样,可以优雅的按层遍历.</p> <p>zigzag的方式,我们可以设置一个变量,每次遍历后取反来控制状态.</p> <p>我们根据这个状态,控制当前从队列的头还是尾拿出来,然后判断从头还是尾加入.</p> <h4 id="_20-6-188-convert-sorted-array-to-binary-search-tree"><a href="#_20-6-188-convert-sorted-array-to-binary-search-tree" class="header-anchor">#</a> 20-6-188-convert-sorted-array-to-binary-search-tree/</h4> <p>https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</p> <blockquote><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡二叉树是一棵满足每个节点的左右两个子树的高度差的绝对值不超过1的二叉树</p></blockquote> <p>Node head = f(arr,L,R),做一个这样的函数,</p> <p>M位置就是head,返回head,</p> <p>head的左就是L,M范围返回的头,连上呗.</p> <p>右边连上M+1,R的返回的node,</p> <p>20-7-189-populating-next-right-pointers-in-each-node/</p> <p>https://leetcode.com/problems/populating-next-right-pointers-in-each-node/</p> <blockquote><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node {
int val;
Node *left;
Node *right;
Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
进阶：
这棵树如果是普通二叉树，该怎么做。
你只能使用常量级额外空间。</p></blockquote> <p>你不能用队列, 要求额外空间复杂度O(1),</p> <p>这个还是宽度优先遍历,但是不能使用额外的队列.</p> <p>那就借用他本身的节点呗, 我不再额外的开辟空间了,我自定义一个queue,只记录,头,尾,size.</p> <p>题目本身就是让我弄next,链接他右边的,那不是正好吗?</p> <p>我还是每次来节点的时候,我只记录头尾,让他们自己的next去连去,我只记录头尾,size.</p> <p>依然是,每次的for循环,只for  size个.</p> <h2 id="前缀树"><a href="#前缀树" class="header-anchor">#</a> 前缀树</h2> <h4 id="异或和最大问题"><a href="#异或和最大问题" class="header-anchor">#</a> 异或和最大问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=34967&amp;courseVersionId=1348</p> <blockquote><p>数组中所有数异或的结果叫做异或和,给定一个数组arr,返回arr的最大子数组异或和.</p></blockquote> <p>思路:前缀树,</p> <p>看到子数组,肯定是以某个位置结尾,看看前面推到哪里</p> <p>假如0-5个数,以5为结尾,0-5异或和为a</p> <p>如果1个数都不选,那就是a^0,</p> <p>如果选0-1,那假设为b,a^b 代表1-5的异或和.</p> <h4 id="_26-3-152-wordsearch2"><a href="#_26-3-152-wordsearch2" class="header-anchor">#</a> 26-3-152-wordSearch2</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35081&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/word-search-ii/</p> <blockquote><p>给定一个m*n大小的单词表,再给定一组单词,问能否找到能走出来的单词.不能走回头路,走出来的,记录,返回所有能走出来的单词</p></blockquote> <p>最优解,前缀树,先给这组单词组成一颗前缀树.用这颗前缀树来提示我.</p> <p>这个是考察一个暴力递归,深度优先遍历.写的熟不熟.</p> <p>每个点出发后,前缀树有没有,有上下左右,只要不越界,跳下一个节点,没有直接不走了,</p> <p>跳下一个节点了,前缀树有没有去这个节点的,有,继续深度优先遍历,直到,找到了一个单词,是end了,开始回退,</p> <p>==重要优化,回退时候,前缀树的pass属性,-1,我已经找到了目标数组中的,假设这条路的pass==0了,没必要再走了,重要剪枝!!.==</p> <h2 id="并查集"><a href="#并查集" class="header-anchor">#</a> 并查集</h2> <h4 id="_13-4-87-bricks-falling-when-hit-打方块-消消乐问题"><a href="#_13-4-87-bricks-falling-when-hit-打方块-消消乐问题" class="header-anchor">#</a> 13-4-87 bricks falling when hit 打方块,消消乐问题</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35016&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/bricks-falling-when-hit/</p> <blockquote><p>就是说一个二维矩阵,其中最上面的一行是天花板,然后呢,1代表一些砖块,上下左右是有粘性的,如果1上面是天花板,他会粘在天花板上,侧面不会,如果1的左右,或者上面连着1,且他这个1是天花板相连的,那他能挂住,否则实际上一开始,不连着的,就掉下去了.</p> <p>再给定一个只有2列的数组,这个数组代表的是炮弹的位置,如果说,开炮后,打中了0位置,那就相当于没法说,如果打中了1,那这个1就会被打碎了,他后面连着的1,如果没有其他链接了,就会断了,掉下去了,</p> <p>问,打了每一炮之后,剩余的砖块数量.</p></blockquote> <p>这个题,我们倒着来求解,也就是假设3发炮弹,我们先求第三发影响了多少,然后求2影响了多少,然后求1,</p> <p>我们给每一个炮弹的影响,都把1改为2,然后全部开炮完了后,剩下的内容,做并查集,唯一的区别是,这个并查集,加了一个属性,判断是否是连接天花板,</p> <p>然后开始回退炮弹,每次回退时,如果是2,改为1,然后加入到并查集中,连接他的上下左右,当影响了一个是天花板,一个不是的时候,会影响天花板的砖块数量,否则没实际影响.直到回退完所有的炮弹,也就得出了每一步的结果.</p> <h3 id="贪心问题"><a href="#贪心问题" class="header-anchor">#</a> 贪心问题</h3> <h4 id="_24-6-145-remove-duplicate-letters"><a href="#_24-6-145-remove-duplicate-letters" class="header-anchor">#</a> 24-6-145-remove-duplicate-letters</h4> <p>https://www.mashibing.com/study?courseNo=465&amp;sectionNo=35074&amp;courseVersionId=1348</p> <p>https://leetcode.com/problems/remove-duplicate-letters/</p> <blockquote><p>一个字符串,删除重复的字符,使字典序最小.</p></blockquote> <p>统计所有的词频!</p> <p>然后扩窗口,扩一个,对应的词频－1,当某个字符耗尽的时候,任何的字符耗尽都行,</p> <p>这个窗口里,取个最小的字符,然后,</p> <ol><li>删除后续所有的选中的字符,我已经选完了要哪个了,剩下的删掉.</li> <li>窗口的左边界,来到选中字符的下一个位置,重新扩,重复上面的步骤.</li></ol> <p>k种字符,每个走N遍.复杂度O(k*N)大写加小写一般52中,所以O(N)</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/算法体系/算法新手班.html" class="prev">
        算法新手班
      </a></span> <span class="next"><a href="/算法体系/7-堆-被火车撞了都不能忘记的结构.html">
        堆-被火车撞了都不能忘记的结构
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.830e2a66.js" defer></script><script src="/assets/js/2.fa03b954.js" defer></script><script src="/assets/js/1.f1cca222.js" defer></script><script src="/assets/js/24.300b4c09.js" defer></script>
  </body>
</html>
